
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="lang:clipboard.copy" content="Copy to clipboard">
  <meta name="lang:clipboard.copied" content="Copied to clipboard">
  <meta name="lang:search.language" content="en">
  <meta name="lang:search.pipeline.stopwords" content="True">
  <meta name="lang:search.pipeline.trimmer" content="True">
  <meta name="lang:search.result.none" content="No matching documents">
  <meta name="lang:search.result.one" content="1 matching document">
  <meta name="lang:search.result.other" content="# matching documents">
  <meta name="lang:search.tokenizer" content="[\s\-]+">

  
    <link href="https://fonts.gstatic.com/" rel="preconnect" crossorigin>
    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,500,700|Roboto:300,400,400i,700&display=fallback" rel="stylesheet">

    <style>
      body,
      input {
        font-family: "Roboto", "Helvetica Neue", Helvetica, Arial, sans-serif
      }

      code,
      kbd,
      pre {
        font-family: "Roboto Mono", "Courier New", Courier, monospace
      }
    </style>
  

  <link rel="stylesheet" href="../../../_static/stylesheets/application.css"/>
  <link rel="stylesheet" href="../../../_static/stylesheets/application-palette.css"/>
  <link rel="stylesheet" href="../../../_static/stylesheets/application-fixes.css"/>
  
  <link rel="stylesheet" href="../../../_static/fonts/material-icons.css"/>
  
  <meta name="theme-color" content="#3f51b5">
  <script src="../../../_static/javascripts/modernizr.js"></script>
  
  
  
    <title>sqlalchemy.sql.elements &#8212; DBBase 0.3.3 documentation</title>
    <link rel="stylesheet" href="../../../_static/material.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  
   
  
  <script src="../../../_static/javascripts/version_dropdown.js"></script>
  <script>
    var json_loc = "../../../"versions.json"",
        target_loc = "../../../../",
        text = "Versions";
    $( document ).ready( add_version_dropdown(json_loc, target_loc, text));
  </script>


  </head>
  <body dir=ltr
        data-md-color-primary=blue data-md-color-accent=blue>
  
  <svg class="md-svg">
    <defs data-children-count="0">
      
      <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
      
    </defs>
  </svg>
  
  <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer">
  <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search">
  <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
  <a href="#_modules/sqlalchemy/sql/elements" tabindex="1" class="md-skip"> Skip to content </a>
  <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex navheader">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../../../index.html" title="DBBase 0.3.3 documentation"
           class="md-header-nav__button md-logo">
          
            &nbsp;
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          <span class="md-header-nav__topic">DBBase 0.3.3</span>
          <span class="md-header-nav__topic"> sqlalchemy.sql.elements </span>
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
        
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" action="../../../search.html" method="GET" name="search">
      <input type="text" class="md-search__input" name="q" placeholder="Search"
             autocapitalize="off" autocomplete="off" spellcheck="false"
             data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>

      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            <a href="https://github.com/sidorof/dbbase/" title="Go to repository" class="md-source" data-md-source="github">

    <div class="md-source__icon">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="28" height="28">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    dbbase
  </div>
</a>
          </div>
        </div>
      
    </div>
  </nav>
</header>

  
  <div class="md-container">
    
    
    
  <nav class="md-tabs" data-md-component="tabs">
    <div class="md-tabs__inner md-grid">
      <ul class="md-tabs__list">
          <li class="md-tabs__item"><a href="../../../index.html" class="md-tabs__link">DBBase 0.3.3 documentation</a></li>
          <li class="md-tabs__item"><a href="../../index.html" class="md-tabs__link">Module code</a></li>
      </ul>
    </div>
  </nav>
    <main class="md-main">
      <div class="md-main__inner md-grid" data-md-component="container">
        
          <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../../../index.html" title="DBBase 0.3.3 documentation" class="md-nav__button md-logo">
      
        <img src="../../../_static/" alt=" logo" width="48" height="48">
      
    </a>
    <a href="../../../index.html"
       title="DBBase 0.3.3 documentation">DBBase 0.3.3</a>
  </label>
    <div class="md-nav__source">
      <a href="https://github.com/sidorof/dbbase/" title="Go to repository" class="md-source" data-md-source="github">

    <div class="md-source__icon">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="28" height="28">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    dbbase
  </div>
</a>
    </div>
  
  

  
  
    <p class="caption"><span class="caption-text">Contents:</span></p>
  
  <ul class="md-nav__list">
    <li class="md-nav__item">
    
      <a href="../../../installation.html" class="md-nav__link">Installation</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../../../user_guide.html" class="md-nav__link">User Guide</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../../../examples.html" class="md-nav__link">Examples</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../../../api.html" class="md-nav__link">API Reference</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../../../testing.html" class="md-nav__link">Running Unit Tests</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../../../license.html" class="md-nav__link">License</a>
      
    </li>
    <li class="md-nav__item">
    
      <a href="../../../changelog.html" class="md-nav__link">Changelog</a>
      
    </li>
  </ul>
  

</nav>
              </div>
            </div>
          </div>
          <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                
<nav class="md-nav md-nav--secondary">
  <ul class="md-nav__list" data-md-scrollfix="">
    

<li id="searchbox" class="md-nav__item"></li>

  </ul>
</nav>
              </div>
            </div>
          </div>
        
        <div class="md-content">
          <article class="md-content__inner md-typeset" role="main">
            
  <h1 id="modules-sqlalchemy-sql-elements--page-root">Source code for sqlalchemy.sql.elements</h1><div class="highlight"><pre>
<span></span><span class="c1"># sql/elements.py</span>
<span class="c1"># Copyright (C) 2005-2020 the SQLAlchemy authors and contributors</span>
<span class="c1"># &lt;see AUTHORS file&gt;</span>
<span class="c1">#</span>
<span class="c1"># This module is part of SQLAlchemy and is released under</span>
<span class="c1"># the MIT License: http://www.opensource.org/licenses/mit-license.php</span>

<span class="sd">"""Core SQL expression elements, including :class:`.ClauseElement`,</span>
<span class="sd">:class:`.ColumnElement`, and derived classes.</span>

<span class="sd">"""</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">unicode_literals</span>

<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">operators</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">type_api</span>
<span class="kn">from</span> <span class="nn">.annotation</span> <span class="kn">import</span> <span class="n">Annotated</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="n">_generative</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="n">Executable</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="n">Immutable</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="n">NO_ARG</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="n">PARSE_AUTOCOMMIT</span>
<span class="kn">from</span> <span class="nn">.visitors</span> <span class="kn">import</span> <span class="n">cloned_traverse</span>
<span class="kn">from</span> <span class="nn">.visitors</span> <span class="kn">import</span> <span class="n">traverse</span>
<span class="kn">from</span> <span class="nn">.visitors</span> <span class="kn">import</span> <span class="n">Visitable</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">exc</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">inspection</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">util</span>


<span class="k">def</span> <span class="nf">_clone</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">element</span><span class="o">.</span><span class="n">_clone</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_document_text_coercion</span><span class="p">(</span><span class="n">paramname</span><span class="p">,</span> <span class="n">meth_rst</span><span class="p">,</span> <span class="n">param_rst</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">add_parameter_text</span><span class="p">(</span>
        <span class="n">paramname</span><span class="p">,</span>
        <span class="p">(</span>
            <span class="s2">".. warning:: "</span>
            <span class="s2">"The </span><span class="si">%s</span><span class="s2"> argument to </span><span class="si">%s</span><span class="s2"> can be passed as a Python string argument, "</span>
            <span class="s2">"which will be treated "</span>
            <span class="s2">"as **trusted SQL text** and rendered as given.  **DO NOT PASS "</span>
            <span class="s2">"UNTRUSTED INPUT TO THIS PARAMETER**."</span>
        <span class="p">)</span>
        <span class="o">%</span> <span class="p">(</span><span class="n">param_rst</span><span class="p">,</span> <span class="n">meth_rst</span><span class="p">),</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">collate</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">collation</span><span class="p">):</span>
    <span class="sd">"""Return the clause ``expression COLLATE collation``.</span>

<span class="sd">    e.g.::</span>

<span class="sd">        collate(mycolumn, 'utf8_bin')</span>

<span class="sd">    produces::</span>

<span class="sd">        mycolumn COLLATE utf8_bin</span>

<span class="sd">    The collation expression is also quoted if it is a case sensitive</span>
<span class="sd">    identifier, e.g. contains uppercase characters.</span>

<span class="sd">    .. versionchanged:: 1.2 quoting is automatically applied to COLLATE</span>
<span class="sd">       expressions if they are case sensitive.</span>

<span class="sd">    """</span>

    <span class="n">expr</span> <span class="o">=</span> <span class="n">_literal_as_binds</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BinaryExpression</span><span class="p">(</span>
        <span class="n">expr</span><span class="p">,</span> <span class="n">CollationClause</span><span class="p">(</span><span class="n">collation</span><span class="p">),</span> <span class="n">operators</span><span class="o">.</span><span class="n">collate</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="n">expr</span><span class="o">.</span><span class="n">type</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">between</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">"""Produce a ``BETWEEN`` predicate clause.</span>

<span class="sd">    E.g.::</span>

<span class="sd">        from sqlalchemy import between</span>
<span class="sd">        stmt = select([users_table]).where(between(users_table.c.id, 5, 7))</span>

<span class="sd">    Would produce SQL resembling::</span>

<span class="sd">        SELECT id, name FROM user WHERE id BETWEEN :id_1 AND :id_2</span>

<span class="sd">    The :func:`.between` function is a standalone version of the</span>
<span class="sd">    :meth:`.ColumnElement.between` method available on all</span>
<span class="sd">    SQL expressions, as in::</span>

<span class="sd">        stmt = select([users_table]).where(users_table.c.id.between(5, 7))</span>

<span class="sd">    All arguments passed to :func:`.between`, including the left side</span>
<span class="sd">    column expression, are coerced from Python scalar values if a</span>
<span class="sd">    the value is not a :class:`.ColumnElement` subclass.   For example,</span>
<span class="sd">    three fixed values can be compared as in::</span>

<span class="sd">        print(between(5, 3, 7))</span>

<span class="sd">    Which would produce::</span>

<span class="sd">        :param_1 BETWEEN :param_2 AND :param_3</span>

<span class="sd">    :param expr: a column expression, typically a :class:`.ColumnElement`</span>
<span class="sd">     instance or alternatively a Python scalar expression to be coerced</span>
<span class="sd">     into a column expression, serving as the left side of the ``BETWEEN``</span>
<span class="sd">     expression.</span>

<span class="sd">    :param lower_bound: a column or Python scalar expression serving as the</span>
<span class="sd">     lower bound of the right side of the ``BETWEEN`` expression.</span>

<span class="sd">    :param upper_bound: a column or Python scalar expression serving as the</span>
<span class="sd">     upper bound of the right side of the ``BETWEEN`` expression.</span>

<span class="sd">    :param symmetric: if True, will render " BETWEEN SYMMETRIC ". Note</span>
<span class="sd">     that not all databases support this syntax.</span>

<span class="sd">     .. versionadded:: 0.9.5</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :meth:`.ColumnElement.between`</span>

<span class="sd">    """</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">_literal_as_binds</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">between</span><span class="p">(</span><span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">,</span> <span class="n">symmetric</span><span class="o">=</span><span class="n">symmetric</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">literal</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""Return a literal clause, bound to a bind parameter.</span>

<span class="sd">    Literal clauses are created automatically when non-</span>
<span class="sd">    :class:`.ClauseElement` objects (such as strings, ints, dates, etc.) are</span>
<span class="sd">    used in a comparison operation with a :class:`.ColumnElement` subclass,</span>
<span class="sd">    such as a :class:`~sqlalchemy.schema.Column` object.  Use this function</span>
<span class="sd">    to force the generation of a literal clause, which will be created as a</span>
<span class="sd">    :class:`BindParameter` with a bound value.</span>

<span class="sd">    :param value: the value to be bound. Can be any Python object supported by</span>
<span class="sd">        the underlying DB-API, or is translatable via the given type argument.</span>

<span class="sd">    :param type\_: an optional :class:`~sqlalchemy.types.TypeEngine` which</span>
<span class="sd">        will provide bind-parameter translation for this literal.</span>

<span class="sd">    """</span>
    <span class="k">return</span> <span class="n">BindParameter</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="n">type_</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">outparam</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">"""Create an 'OUT' parameter for usage in functions (stored procedures),</span>
<span class="sd">    for databases which support them.</span>

<span class="sd">    The ``outparam`` can be used like a regular function parameter.</span>
<span class="sd">    The "output" value will be available from the</span>
<span class="sd">    :class:`~sqlalchemy.engine.ResultProxy` object via its ``out_parameters``</span>
<span class="sd">    attribute, which returns a dictionary containing the values.</span>

<span class="sd">    """</span>
    <span class="k">return</span> <span class="n">BindParameter</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="n">type_</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">isoutparam</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">not_</span><span class="p">(</span><span class="n">clause</span><span class="p">):</span>
    <span class="sd">"""Return a negation of the given clause, i.e. ``NOT(clause)``.</span>

<span class="sd">    The ``~`` operator is also overloaded on all</span>
<span class="sd">    :class:`.ColumnElement` subclasses to produce the</span>
<span class="sd">    same result.</span>

<span class="sd">    """</span>
    <span class="k">return</span> <span class="n">operators</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">_literal_as_binds</span><span class="p">(</span><span class="n">clause</span><span class="p">))</span>


<span class="nd">@inspection</span><span class="o">.</span><span class="n">_self_inspects</span>
<span class="k">class</span> <span class="nc">ClauseElement</span><span class="p">(</span><span class="n">Visitable</span><span class="p">):</span>
    <span class="sd">"""Base class for elements of a programmatically constructed SQL</span>
<span class="sd">    expression.</span>

<span class="sd">    """</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s2">"clause"</span>

    <span class="n">_annotations</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">supports_execution</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_from_objects</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">bind</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_is_clone_of</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">is_selectable</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_clause_element</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">description</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_order_by_label_element</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_is_from_container</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_clone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Create a shallow copy of this ClauseElement.</span>

<span class="sd">        This method may be used by a generative API.  Its also used as</span>
<span class="sd">        part of the "deep" copy afforded by a traversal that combines</span>
<span class="sd">        the _copy_internals() method.</span>

<span class="sd">        """</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="n">c</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ClauseElement</span><span class="o">.</span><span class="n">_cloned_set</span><span class="o">.</span><span class="n">_reset</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">ColumnElement</span><span class="o">.</span><span class="n">comparator</span><span class="o">.</span><span class="n">_reset</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

        <span class="c1"># this is a marker that helps to "equate" clauses to each other</span>
        <span class="c1"># when a Select returns its list of FROM clauses.  the cloning</span>
        <span class="c1"># process leaves around a lot of remnants of the previous clause</span>
        <span class="c1"># typically in the form of column expressions still attached to the</span>
        <span class="c1"># old table.</span>
        <span class="n">c</span><span class="o">.</span><span class="n">_is_clone_of</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">return</span> <span class="n">c</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""return the 'constructor' for this ClauseElement.</span>

<span class="sd">        This is for the purposes for creating a new object of</span>
<span class="sd">        this type.   Usually, its just the element's __class__.</span>
<span class="sd">        However, the "Annotated" version of the object overrides</span>
<span class="sd">        to return the class of its proxied element.</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">memoized_property</span>
    <span class="k">def</span> <span class="nf">_cloned_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Return the set consisting all cloned ancestors of this</span>
<span class="sd">        ClauseElement.</span>

<span class="sd">        Includes this ClauseElement.  This accessor tends to be used for</span>
<span class="sd">        FromClause objects to identify 'equivalent' FROM clauses, regardless</span>
<span class="sd">        of transformative operations.</span>

<span class="sd">        """</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">column_set</span><span class="p">()</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="c1"># note this creates a cycle, asserted in test_memusage. however,</span>
        <span class="c1"># turning this into a plain @property adds tends of thousands of method</span>
        <span class="c1"># calls to Core / ORM performance tests, so the small overhead</span>
        <span class="c1"># introduced by the relatively small amount of short term cycles</span>
        <span class="c1"># produced here is preferable</span>
        <span class="k">while</span> <span class="n">f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">_is_clone_of</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"_is_clone_of"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">_annotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">"""return a copy of this ClauseElement with annotations</span>
<span class="sd">        updated by the given dictionary.</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">Annotated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_with_annotations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">"""return a copy of this ClauseElement with annotations</span>
<span class="sd">        replaced by the given dictionary.</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">Annotated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_deannotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">"""return a copy of this :class:`.ClauseElement` with annotations</span>
<span class="sd">        removed.</span>

<span class="sd">        :param values: optional tuple of individual values</span>
<span class="sd">         to remove.</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">clone</span><span class="p">:</span>
            <span class="c1"># clone is used when we are also copying</span>
            <span class="c1"># the expression for a deep deannotation</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># if no clone, since we have no annotations we return</span>
            <span class="c1"># self</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_execute_on_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">multiparams</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">supports_execution</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">connection</span><span class="o">.</span><span class="n">_execute_clauseelement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multiparams</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">ObjectNotExecutableError</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">unique_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">optionaldict</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Return a copy with :func:`bindparam()` elements replaced.</span>

<span class="sd">        Same functionality as ``params()``, except adds `unique=True`</span>
<span class="sd">        to affected bind parameters so that multiple statements can be</span>
<span class="sd">        used.</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">optionaldict</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">optionaldict</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Return a copy with :func:`bindparam()` elements replaced.</span>

<span class="sd">        Returns a copy of this ClauseElement with :func:`bindparam()`</span>
<span class="sd">        elements replaced with values taken from the given dictionary::</span>

<span class="sd">          &gt;&gt;&gt; clause = column('x') + bindparam('foo')</span>
<span class="sd">          &gt;&gt;&gt; print(clause.compile().params)</span>
<span class="sd">          {'foo':None}</span>
<span class="sd">          &gt;&gt;&gt; print(clause.params({'foo':7}).compile().params)</span>
<span class="sd">          {'foo':7}</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">optionaldict</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unique</span><span class="p">,</span> <span class="n">optionaldict</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">optionaldict</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">optionaldict</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">optionaldict</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
                <span class="s2">"params() takes zero or one positional dictionary argument"</span>
            <span class="p">)</span>

        <span class="k">def</span> <span class="nf">visit_bindparam</span><span class="p">(</span><span class="n">bind</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">bind</span><span class="o">.</span><span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">bind</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">bind</span><span class="o">.</span><span class="n">key</span><span class="p">]</span>
                <span class="n">bind</span><span class="o">.</span><span class="n">required</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">unique</span><span class="p">:</span>
                <span class="n">bind</span><span class="o">.</span><span class="n">_convert_to_unique</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">cloned_traverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">{},</span> <span class="p">{</span><span class="s2">"bindparam"</span><span class="p">:</span> <span class="n">visit_bindparam</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Compare this ClauseElement to the given ClauseElement.</span>

<span class="sd">        Subclasses should override the default behavior, which is a</span>
<span class="sd">        straight identity comparison.</span>

<span class="sd">        \**kw are arguments consumed by subclass compare() methods and</span>
<span class="sd">        may be used to modify the criteria for comparison.</span>
<span class="sd">        (see :class:`.ColumnElement`)</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">_copy_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">_clone</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">"""Reassign internal elements to be clones of themselves.</span>

<span class="sd">        Called during a copy-and-traverse operation on newly</span>
<span class="sd">        shallow-copied elements to create a deep copy.</span>

<span class="sd">        The given clone function should be used, which may be applying</span>
<span class="sd">        additional transformations to the element (i.e. replacement</span>
<span class="sd">        traversal, cloned traversal, annotations).</span>

<span class="sd">        """</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Return immediate child elements of this :class:`.ClauseElement`.</span>

<span class="sd">        This is used for visit traversal.</span>

<span class="sd">        \**kwargs may contain flags that change the collection that is</span>
<span class="sd">        returned, for example to return a subset of items in order to</span>
<span class="sd">        cut down on larger traversals, or to return child items from a</span>
<span class="sd">        different context (such as schema-level collections instead of</span>
<span class="sd">        clause-level).</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">self_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">against</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""Apply a 'grouping' to this :class:`.ClauseElement`.</span>

<span class="sd">        This method is overridden by subclasses to return a</span>
<span class="sd">        "grouping" construct, i.e. parenthesis.   In particular</span>
<span class="sd">        it's used by "binary" expressions to provide a grouping</span>
<span class="sd">        around themselves when placed into a larger expression,</span>
<span class="sd">        as well as by :func:`.select` constructs when placed into</span>
<span class="sd">        the FROM clause of another :func:`.select`.  (Note that</span>
<span class="sd">        subqueries should be normally created using the</span>
<span class="sd">        :meth:`.Select.alias` method, as many platforms require</span>
<span class="sd">        nested SELECT statements to be named).</span>

<span class="sd">        As expressions are composed together, the application of</span>
<span class="sd">        :meth:`self_group` is automatic - end-user code should never</span>
<span class="sd">        need to use this method directly.  Note that SQLAlchemy's</span>
<span class="sd">        clause constructs take operator precedence into account -</span>
<span class="sd">        so parenthesis might not be needed, for example, in</span>
<span class="sd">        an expression like ``x OR (y AND z)`` - AND takes precedence</span>
<span class="sd">        over OR.</span>

<span class="sd">        The base :meth:`self_group` method of :class:`.ClauseElement`</span>
<span class="sd">        just returns self.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">dependencies</span><span class="p">(</span><span class="s2">"sqlalchemy.engine.default"</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">compile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">default</span><span class="p">,</span> <span class="n">bind</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dialect</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">"""Compile this SQL expression.</span>

<span class="sd">        The return value is a :class:`~.Compiled` object.</span>
<span class="sd">        Calling ``str()`` or ``unicode()`` on the returned value will yield a</span>
<span class="sd">        string representation of the result. The</span>
<span class="sd">        :class:`~.Compiled` object also can return a</span>
<span class="sd">        dictionary of bind parameter names and values</span>
<span class="sd">        using the ``params`` accessor.</span>

<span class="sd">        :param bind: An ``Engine`` or ``Connection`` from which a</span>
<span class="sd">            ``Compiled`` will be acquired. This argument takes precedence over</span>
<span class="sd">            this :class:`.ClauseElement`'s bound engine, if any.</span>

<span class="sd">        :param column_keys: Used for INSERT and UPDATE statements, a list of</span>
<span class="sd">            column names which should be present in the VALUES clause of the</span>
<span class="sd">            compiled statement. If ``None``, all columns from the target table</span>
<span class="sd">            object are rendered.</span>

<span class="sd">        :param dialect: A ``Dialect`` instance from which a ``Compiled``</span>
<span class="sd">            will be acquired. This argument takes precedence over the `bind`</span>
<span class="sd">            argument as well as this :class:`.ClauseElement`'s bound engine,</span>
<span class="sd">            if any.</span>

<span class="sd">        :param inline: Used for INSERT statements, for a dialect which does</span>
<span class="sd">            not support inline retrieval of newly generated primary key</span>
<span class="sd">            columns, will force the expression used to create the new primary</span>
<span class="sd">            key value to be rendered inline within the INSERT statement's</span>
<span class="sd">            VALUES clause. This typically refers to Sequence execution but may</span>
<span class="sd">            also refer to any server-side default generation function</span>
<span class="sd">            associated with a primary key `Column`.</span>

<span class="sd">        :param compile_kwargs: optional dictionary of additional parameters</span>
<span class="sd">            that will be passed through to the compiler within all "visit"</span>
<span class="sd">            methods.  This allows any custom flag to be passed through to</span>
<span class="sd">            a custom compilation construct, for example.  It is also used</span>
<span class="sd">            for the case of passing the ``literal_binds`` flag through::</span>

<span class="sd">                from sqlalchemy.sql import table, column, select</span>

<span class="sd">                t = table('t', column('x'))</span>

<span class="sd">                s = select([t]).where(t.c.x == 5)</span>

<span class="sd">                print(s.compile(compile_kwargs={"literal_binds": True}))</span>

<span class="sd">            .. versionadded:: 0.9.0</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`faq_sql_expression_string`</span>

<span class="sd">        """</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">dialect</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bind</span><span class="p">:</span>
                <span class="n">dialect</span> <span class="o">=</span> <span class="n">bind</span><span class="o">.</span><span class="n">dialect</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">bind</span><span class="p">:</span>
                <span class="n">dialect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bind</span><span class="o">.</span><span class="n">dialect</span>
                <span class="n">bind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bind</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dialect</span> <span class="o">=</span> <span class="n">default</span><span class="o">.</span><span class="n">StrCompileDialect</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compiler</span><span class="p">(</span><span class="n">dialect</span><span class="p">,</span> <span class="n">bind</span><span class="o">=</span><span class="n">bind</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_compiler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dialect</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">"""Return a compiler appropriate for this ClauseElement, given a</span>
<span class="sd">        Dialect."""</span>

        <span class="k">return</span> <span class="n">dialect</span><span class="o">.</span><span class="n">statement_compiler</span><span class="p">(</span><span class="n">dialect</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">util</span><span class="o">.</span><span class="n">py3k</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compile</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">unicode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compile</span><span class="p">())</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span>  <span class="c1"># noqa</span>
                <span class="s2">"ascii"</span><span class="p">,</span> <span class="s2">"backslashreplace"</span>
            <span class="p">)</span>  <span class="c1"># noqa</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span>
        <span class="s2">"0.9"</span><span class="p">,</span>
        <span class="s2">"The :meth:`.ClauseElement.__and__` method is deprecated and will "</span>
        <span class="s2">"be removed in a future release.   Conjunctions should only be "</span>
        <span class="s2">"used from a :class:`.ColumnElement` subclass, e.g. "</span>
        <span class="s2">":meth:`.ColumnElement.__and__`."</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="fm">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""'and' at the ClauseElement level.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">and_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span>
        <span class="s2">"0.9"</span><span class="p">,</span>
        <span class="s2">"The :meth:`.ClauseElement.__or__` method is deprecated and will "</span>
        <span class="s2">"be removed in a future release.   Conjunctions should only be "</span>
        <span class="s2">"used from a :class:`.ColumnElement` subclass, e.g. "</span>
        <span class="s2">":meth:`.ColumnElement.__or__`."</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""'or' at the ClauseElement level.</span>
<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">or_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"negation_clause"</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">negation_clause</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negate</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_negate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">UnaryExpression</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">self_group</span><span class="p">(</span><span class="n">against</span><span class="o">=</span><span class="n">operators</span><span class="o">.</span><span class="n">inv</span><span class="p">),</span>
            <span class="n">operator</span><span class="o">=</span><span class="n">operators</span><span class="o">.</span><span class="n">inv</span><span class="p">,</span>
            <span class="n">negate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"Boolean value of this clause is not defined"</span><span class="p">)</span>

    <span class="n">__nonzero__</span> <span class="o">=</span> <span class="fm">__bool__</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">friendly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">description</span>
        <span class="k">if</span> <span class="n">friendly</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">"&lt;</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2"> at 0x</span><span class="si">%x</span><span class="s2">; </span><span class="si">%s</span><span class="s2">&gt;"</span> <span class="o">%</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
                <span class="n">friendly</span><span class="p">,</span>
            <span class="p">)</span>


<span class="k">class</span> <span class="nc">ColumnElement</span><span class="p">(</span><span class="n">operators</span><span class="o">.</span><span class="n">ColumnOperators</span><span class="p">,</span> <span class="n">ClauseElement</span><span class="p">):</span>
    <span class="sd">"""Represent a column-oriented SQL expression suitable for usage in the</span>
<span class="sd">    "columns" clause, WHERE clause etc. of a statement.</span>

<span class="sd">    While the most familiar kind of :class:`.ColumnElement` is the</span>
<span class="sd">    :class:`.Column` object, :class:`.ColumnElement` serves as the basis</span>
<span class="sd">    for any unit that may be present in a SQL expression, including</span>
<span class="sd">    the expressions themselves, SQL functions, bound parameters,</span>
<span class="sd">    literal expressions, keywords such as ``NULL``, etc.</span>
<span class="sd">    :class:`.ColumnElement` is the ultimate base class for all such elements.</span>

<span class="sd">    A wide variety of SQLAlchemy Core functions work at the SQL expression</span>
<span class="sd">    level, and are intended to accept instances of :class:`.ColumnElement` as</span>
<span class="sd">    arguments.  These functions will typically document that they accept a</span>
<span class="sd">    "SQL expression" as an argument.  What this means in terms of SQLAlchemy</span>
<span class="sd">    usually refers to an input which is either already in the form of a</span>
<span class="sd">    :class:`.ColumnElement` object, or a value which can be **coerced** into</span>
<span class="sd">    one.  The coercion rules followed by most, but not all, SQLAlchemy Core</span>
<span class="sd">    functions with regards to SQL expressions are as follows:</span>

<span class="sd">        * a literal Python value, such as a string, integer or floating</span>
<span class="sd">          point value, boolean, datetime, ``Decimal`` object, or virtually</span>
<span class="sd">          any other Python object, will be coerced into a "literal bound</span>
<span class="sd">          value".  This generally means that a :func:`.bindparam` will be</span>
<span class="sd">          produced featuring the given value embedded into the construct; the</span>
<span class="sd">          resulting :class:`.BindParameter` object is an instance of</span>
<span class="sd">          :class:`.ColumnElement`.  The Python value will ultimately be sent</span>
<span class="sd">          to the DBAPI at execution time as a parameterized argument to the</span>
<span class="sd">          ``execute()`` or ``executemany()`` methods, after SQLAlchemy</span>
<span class="sd">          type-specific converters (e.g. those provided by any associated</span>
<span class="sd">          :class:`.TypeEngine` objects) are applied to the value.</span>

<span class="sd">        * any special object value, typically ORM-level constructs, which</span>
<span class="sd">          feature a method called ``__clause_element__()``.  The Core</span>
<span class="sd">          expression system looks for this method when an object of otherwise</span>
<span class="sd">          unknown type is passed to a function that is looking to coerce the</span>
<span class="sd">          argument into a :class:`.ColumnElement` expression.  The</span>
<span class="sd">          ``__clause_element__()`` method, if present, should return a</span>
<span class="sd">          :class:`.ColumnElement` instance.  The primary use of</span>
<span class="sd">          ``__clause_element__()`` within SQLAlchemy is that of class-bound</span>
<span class="sd">          attributes on ORM-mapped classes; a ``User`` class which contains a</span>
<span class="sd">          mapped attribute named ``.name`` will have a method</span>
<span class="sd">          ``User.name.__clause_element__()`` which when invoked returns the</span>
<span class="sd">          :class:`.Column` called ``name`` associated with the mapped table.</span>

<span class="sd">        * The Python ``None`` value is typically interpreted as ``NULL``,</span>
<span class="sd">          which in SQLAlchemy Core produces an instance of :func:`.null`.</span>

<span class="sd">    A :class:`.ColumnElement` provides the ability to generate new</span>
<span class="sd">    :class:`.ColumnElement`</span>
<span class="sd">    objects using Python expressions.  This means that Python operators</span>
<span class="sd">    such as ``==``, ``!=`` and ``&lt;`` are overloaded to mimic SQL operations,</span>
<span class="sd">    and allow the instantiation of further :class:`.ColumnElement` instances</span>
<span class="sd">    which are composed from other, more fundamental :class:`.ColumnElement`</span>
<span class="sd">    objects.  For example, two :class:`.ColumnClause` objects can be added</span>
<span class="sd">    together with the addition operator ``+`` to produce</span>
<span class="sd">    a :class:`.BinaryExpression`.</span>
<span class="sd">    Both :class:`.ColumnClause` and :class:`.BinaryExpression` are subclasses</span>
<span class="sd">    of :class:`.ColumnElement`::</span>

<span class="sd">        &gt;&gt;&gt; from sqlalchemy.sql import column</span>
<span class="sd">        &gt;&gt;&gt; column('a') + column('b')</span>
<span class="sd">        &lt;sqlalchemy.sql.expression.BinaryExpression object at 0x101029dd0&gt;</span>
<span class="sd">        &gt;&gt;&gt; print(column('a') + column('b'))</span>
<span class="sd">        a + b</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :class:`.Column`</span>

<span class="sd">        :func:`.expression.column`</span>

<span class="sd">    """</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s2">"column_element"</span>
    <span class="n">primary_key</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">foreign_keys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">_proxies</span> <span class="o">=</span> <span class="p">()</span>

    <span class="n">_label</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">"""The named label that can be used to target</span>
<span class="sd">    this column in a result set.</span>

<span class="sd">    This label is almost always the label used when</span>
<span class="sd">    rendering &lt;expr&gt; AS &lt;label&gt; in a SELECT statement.  It also</span>
<span class="sd">    refers to a name that this column expression can be located from</span>
<span class="sd">    in a result set.</span>

<span class="sd">    For a regular Column bound to a Table, this is typically the label</span>
<span class="sd">    &lt;tablename&gt;_&lt;columnname&gt;.  For other constructs, different rules</span>
<span class="sd">    may apply, such as anonymized labels and others.</span>

<span class="sd">    """</span>

    <span class="n">key</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">"""the 'key' that in some circumstances refers to this object in a</span>
<span class="sd">    Python namespace.</span>

<span class="sd">    This typically refers to the "key" of the column as present in the</span>
<span class="sd">    ``.c`` collection of a selectable, e.g. sometable.c["somekey"] would</span>
<span class="sd">    return a Column with a .key of "somekey".</span>

<span class="sd">    """</span>

    <span class="n">_key_label</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">"""A label-based version of 'key' that in some circumstances refers</span>
<span class="sd">    to this object in a Python namespace.</span>


<span class="sd">    _key_label comes into play when a select() statement is constructed with</span>
<span class="sd">    apply_labels(); in this case, all Column objects in the ``.c`` collection</span>
<span class="sd">    are rendered as &lt;tablename&gt;_&lt;columnname&gt; in SQL; this is essentially the</span>
<span class="sd">    value of ._label.  But to locate those columns in the ``.c`` collection,</span>
<span class="sd">    the name is along the lines of &lt;tablename&gt;_&lt;key&gt;; that's the typical</span>
<span class="sd">    value of .key_label.</span>

<span class="sd">    """</span>

    <span class="n">_render_label_in_columns_clause</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="sd">"""A flag used by select._columns_plus_names that helps to determine</span>
<span class="sd">    we are actually going to render in terms of "SELECT &lt;col&gt; AS &lt;label&gt;".</span>
<span class="sd">    This flag can be returned as False for some Column objects that want</span>
<span class="sd">    to be rendered as simple "SELECT &lt;col&gt;"; typically columns that don't have</span>
<span class="sd">    any parent table and are named the same as what the label would be</span>
<span class="sd">    in any case.</span>

<span class="sd">    """</span>

    <span class="n">_resolve_label</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">"""The name that should be used to identify this ColumnElement in a</span>
<span class="sd">    select() object when "label resolution" logic is used; this refers</span>
<span class="sd">    to using a string name in an expression like order_by() or group_by()</span>
<span class="sd">    that wishes to target a labeled expression in the columns clause.</span>

<span class="sd">    The name is distinct from that of .name or ._label to account for the case</span>
<span class="sd">    where anonymizing logic may be used to change the name that's actually</span>
<span class="sd">    rendered at compile time; this attribute should hold onto the original</span>
<span class="sd">    name that was user-assigned when producing a .label() construct.</span>

<span class="sd">    """</span>

    <span class="n">_allow_label_resolve</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="sd">"""A flag that can be flipped to prevent a column from being resolvable</span>
<span class="sd">    by string label name."""</span>

    <span class="n">_is_implicitly_boolean</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">_alt_names</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="nf">self_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">against</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">against</span> <span class="ow">in</span> <span class="p">(</span><span class="n">operators</span><span class="o">.</span><span class="n">and_</span><span class="p">,</span> <span class="n">operators</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">operators</span><span class="o">.</span><span class="n">_asbool</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">_type_affinity</span> <span class="ow">is</span> <span class="n">type_api</span><span class="o">.</span><span class="n">BOOLEANTYPE</span><span class="o">.</span><span class="n">_type_affinity</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">AsBoolean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operators</span><span class="o">.</span><span class="n">istrue</span><span class="p">,</span> <span class="n">operators</span><span class="o">.</span><span class="n">isfalse</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">against</span> <span class="ow">in</span> <span class="p">(</span><span class="n">operators</span><span class="o">.</span><span class="n">any_op</span><span class="p">,</span> <span class="n">operators</span><span class="o">.</span><span class="n">all_op</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Grouping</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_negate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">_type_affinity</span> <span class="ow">is</span> <span class="n">type_api</span><span class="o">.</span><span class="n">BOOLEANTYPE</span><span class="o">.</span><span class="n">_type_affinity</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">AsBoolean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operators</span><span class="o">.</span><span class="n">isfalse</span><span class="p">,</span> <span class="n">operators</span><span class="o">.</span><span class="n">istrue</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">ColumnElement</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_negate</span><span class="p">()</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">memoized_property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">type_api</span><span class="o">.</span><span class="n">NULLTYPE</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">memoized_property</span>
    <span class="k">def</span> <span class="nf">comparator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">comparator_factory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">comparator_factory</span>
        <span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="n">util</span><span class="o">.</span><span class="n">raise_</span><span class="p">(</span>
                <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">"Object </span><span class="si">%r</span><span class="s2"> associated with '.type' attribute "</span>
                    <span class="s2">"is not a TypeEngine class or object"</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span>
                <span class="p">),</span>
                <span class="n">replace_context</span><span class="o">=</span><span class="n">err</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">comparator_factory</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comparator</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="n">util</span><span class="o">.</span><span class="n">raise_</span><span class="p">(</span>
                <span class="ne">AttributeError</span><span class="p">(</span>
                    <span class="s2">"Neither </span><span class="si">%r</span><span class="s2"> object nor </span><span class="si">%r</span><span class="s2"> object has an attribute </span><span class="si">%r</span><span class="s2">"</span>
                    <span class="o">%</span> <span class="p">(</span>
                        <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                        <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comparator</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                        <span class="n">key</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">),</span>
                <span class="n">replace_context</span><span class="o">=</span><span class="n">err</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">operate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comparator</span><span class="p">,</span> <span class="o">*</span><span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reverse_operate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparator</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_bind_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BindParameter</span><span class="p">(</span>
            <span class="kc">None</span><span class="p">,</span>
            <span class="n">obj</span><span class="p">,</span>
            <span class="n">_compared_to_operator</span><span class="o">=</span><span class="n">operator</span><span class="p">,</span>
            <span class="n">type_</span><span class="o">=</span><span class="n">type_</span><span class="p">,</span>
            <span class="n">_compared_to_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
            <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">expression</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Return a column expression.</span>

<span class="sd">        Part of the inspection interface; returns self.</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_select_iterable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">,)</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">memoized_property</span>
    <span class="k">def</span> <span class="nf">base_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">column_set</span><span class="p">(</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">proxy_set</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">_proxies</span><span class="p">)</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">memoized_property</span>
    <span class="k">def</span> <span class="nf">proxy_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">column_set</span><span class="p">([</span><span class="bp">self</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_proxies</span><span class="p">:</span>
            <span class="n">s</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">proxy_set</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">_uncached_proxy_set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""An 'uncached' version of proxy set.</span>

<span class="sd">        This is so that we can read annotations from the list of columns</span>
<span class="sd">        without breaking the caching of the above proxy_set.</span>

<span class="sd">        """</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">column_set</span><span class="p">([</span><span class="bp">self</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_proxies</span><span class="p">:</span>
            <span class="n">s</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">_uncached_proxy_set</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">shares_lineage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">othercolumn</span><span class="p">):</span>
        <span class="sd">"""Return True if the given :class:`.ColumnElement`</span>
<span class="sd">        has a common ancestor to this :class:`.ColumnElement`."""</span>

        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proxy_set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">othercolumn</span><span class="o">.</span><span class="n">proxy_set</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_compare_name_for_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">"""Return True if the given column element compares to this one</span>
<span class="sd">        when targeting within a result row."""</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">"name"</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"name"</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_make_proxy</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">selectable</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name_is_truncatable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span>
    <span class="p">):</span>
        <span class="sd">"""Create a new :class:`.ColumnElement` representing this</span>
<span class="sd">        :class:`.ColumnElement` as it appears in the select list of a</span>
<span class="sd">        descending selectable.</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">anon_label</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">exc</span><span class="o">.</span><span class="n">UnsupportedCompilationError</span><span class="p">:</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">anon_label</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">name</span>
        <span class="n">co</span> <span class="o">=</span> <span class="n">ColumnClause</span><span class="p">(</span>
            <span class="n">_as_truncated</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">if</span> <span class="n">name_is_truncatable</span> <span class="k">else</span> <span class="n">name</span><span class="p">,</span>
            <span class="n">type_</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"type"</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="n">_selectable</span><span class="o">=</span><span class="n">selectable</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">co</span><span class="o">.</span><span class="n">_proxies</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">selectable</span><span class="o">.</span><span class="n">_is_clone_of</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">co</span><span class="o">.</span><span class="n">_is_clone_of</span> <span class="o">=</span> <span class="n">selectable</span><span class="o">.</span><span class="n">_is_clone_of</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">selectable</span><span class="o">.</span><span class="n">_columns</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">co</span>
        <span class="k">return</span> <span class="n">co</span>

    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">use_proxies</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">equivalents</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">"""Compare this ColumnElement to another.</span>

<span class="sd">        Special arguments understood:</span>

<span class="sd">        :param use_proxies: when True, consider two columns that</span>
<span class="sd">          share a common base column as equivalent (i.e. shares_lineage())</span>

<span class="sd">        :param equivalents: a dictionary of columns as keys mapped to sets</span>
<span class="sd">          of columns. If the given "other" column is present in this</span>
<span class="sd">          dictionary, if any of the columns in the corresponding set() pass</span>
<span class="sd">          the comparison test, the result is True. This is used to expand the</span>
<span class="sd">          comparison to other columns that may be known to be equivalent to</span>
<span class="sd">          this one via foreign key or other criterion.</span>

<span class="sd">        """</span>
        <span class="n">to_compare</span> <span class="o">=</span> <span class="p">(</span><span class="n">other</span><span class="p">,)</span>
        <span class="k">if</span> <span class="n">equivalents</span> <span class="ow">and</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">equivalents</span><span class="p">:</span>
            <span class="n">to_compare</span> <span class="o">=</span> <span class="n">equivalents</span><span class="p">[</span><span class="n">other</span><span class="p">]</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">to_compare</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">oth</span> <span class="ow">in</span> <span class="n">to_compare</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">use_proxies</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">shares_lineage</span><span class="p">(</span><span class="n">oth</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="nb">hash</span><span class="p">(</span><span class="n">oth</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">cast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type_</span><span class="p">):</span>
        <span class="sd">"""Produce a type cast, i.e. ``CAST(&lt;expression&gt; AS &lt;type&gt;)``.</span>

<span class="sd">        This is a shortcut to the :func:`~.expression.cast` function.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`coretutorial_casts`</span>

<span class="sd">            :func:`~.expression.cast`</span>

<span class="sd">            :func:`~.expression.type_coerce`</span>

<span class="sd">        .. versionadded:: 1.0.7</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">Cast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type_</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">"""Produce a column label, i.e. ``&lt;columnname&gt; AS &lt;name&gt;``.</span>

<span class="sd">        This is a shortcut to the :func:`~.expression.label` function.</span>

<span class="sd">        if 'name' is None, an anonymous label name will be generated.</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">Label</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">memoized_property</span>
    <span class="k">def</span> <span class="nf">anon_label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""provides a constant 'anonymous label' for this ColumnElement.</span>

<span class="sd">        This is a label() expression which will be named at compile time.</span>
<span class="sd">        The same label() is returned each time anon_label is called so</span>
<span class="sd">        that expressions can reference anon_label multiple times, producing</span>
<span class="sd">        the same label name at compile time.</span>

<span class="sd">        the compiler uses this function automatically at compile time</span>
<span class="sd">        for expressions that are known to be 'unnamed' like binary</span>
<span class="sd">        expressions and function calls.</span>

<span class="sd">        """</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_clone_of</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_clone_of</span>

        <span class="k">return</span> <span class="n">_anonymous_label</span><span class="p">(</span>
            <span class="s2">"</span><span class="si">%%</span><span class="s2">(</span><span class="si">%d</span><span class="s2"> </span><span class="si">%s</span><span class="s2">)s"</span> <span class="o">%</span> <span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"name"</span><span class="p">,</span> <span class="s2">"anon"</span><span class="p">))</span>
        <span class="p">)</span>


<span class="k">class</span> <span class="nc">BindParameter</span><span class="p">(</span><span class="n">ColumnElement</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""Represent a "bound expression".</span>

<span class="sd">    :class:`.BindParameter` is invoked explicitly using the</span>
<span class="sd">    :func:`.bindparam` function, as in::</span>

<span class="sd">        from sqlalchemy import bindparam</span>

<span class="sd">        stmt = select([users_table]).\</span>
<span class="sd">                    where(users_table.c.name == bindparam('username'))</span>

<span class="sd">    Detailed discussion of how :class:`.BindParameter` is used is</span>
<span class="sd">    at :func:`.bindparam`.</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :func:`.bindparam`</span>

<span class="sd">    """</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s2">"bindparam"</span>

    <span class="n">_is_crud</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_expanding_in_types</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key</span><span class="p">,</span>
        <span class="n">value</span><span class="o">=</span><span class="n">NO_ARG</span><span class="p">,</span>
        <span class="n">type_</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">unique</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">required</span><span class="o">=</span><span class="n">NO_ARG</span><span class="p">,</span>
        <span class="n">quote</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">callable_</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">expanding</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">isoutparam</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">_compared_to_operator</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">_compared_to_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Produce a "bound expression".</span>

<span class="sd">        The return value is an instance of :class:`.BindParameter`; this</span>
<span class="sd">        is a :class:`.ColumnElement` subclass which represents a so-called</span>
<span class="sd">        "placeholder" value in a SQL expression, the value of which is</span>
<span class="sd">        supplied at the point at which the statement in executed against a</span>
<span class="sd">        database connection.</span>

<span class="sd">        In SQLAlchemy, the :func:`.bindparam` construct has</span>
<span class="sd">        the ability to carry along the actual value that will be ultimately</span>
<span class="sd">        used at expression time.  In this way, it serves not just as</span>
<span class="sd">        a "placeholder" for eventual population, but also as a means of</span>
<span class="sd">        representing so-called "unsafe" values which should not be rendered</span>
<span class="sd">        directly in a SQL statement, but rather should be passed along</span>
<span class="sd">        to the :term:`DBAPI` as values which need to be correctly escaped</span>
<span class="sd">        and potentially handled for type-safety.</span>

<span class="sd">        When using :func:`.bindparam` explicitly, the use case is typically</span>
<span class="sd">        one of traditional deferment of parameters; the :func:`.bindparam`</span>
<span class="sd">        construct accepts a name which can then be referred to at execution</span>
<span class="sd">        time::</span>

<span class="sd">            from sqlalchemy import bindparam</span>

<span class="sd">            stmt = select([users_table]).\</span>
<span class="sd">                        where(users_table.c.name == bindparam('username'))</span>

<span class="sd">        The above statement, when rendered, will produce SQL similar to::</span>

<span class="sd">            SELECT id, name FROM user WHERE name = :username</span>

<span class="sd">        In order to populate the value of ``:username`` above, the value</span>
<span class="sd">        would typically be applied at execution time to a method</span>
<span class="sd">        like :meth:`.Connection.execute`::</span>

<span class="sd">            result = connection.execute(stmt, username='wendy')</span>

<span class="sd">        Explicit use of :func:`.bindparam` is also common when producing</span>
<span class="sd">        UPDATE or DELETE statements that are to be invoked multiple times,</span>
<span class="sd">        where the WHERE criterion of the statement is to change on each</span>
<span class="sd">        invocation, such as::</span>

<span class="sd">            stmt = (users_table.update().</span>
<span class="sd">                    where(user_table.c.name == bindparam('username')).</span>
<span class="sd">                    values(fullname=bindparam('fullname'))</span>
<span class="sd">                    )</span>

<span class="sd">            connection.execute(</span>
<span class="sd">                stmt, [{"username": "wendy", "fullname": "Wendy Smith"},</span>
<span class="sd">                       {"username": "jack", "fullname": "Jack Jones"},</span>
<span class="sd">                       ]</span>
<span class="sd">            )</span>

<span class="sd">        SQLAlchemy's Core expression system makes wide use of</span>
<span class="sd">        :func:`.bindparam` in an implicit sense.   It is typical that Python</span>
<span class="sd">        literal values passed to virtually all SQL expression functions are</span>
<span class="sd">        coerced into fixed :func:`.bindparam` constructs.  For example, given</span>
<span class="sd">        a comparison operation such as::</span>

<span class="sd">            expr = users_table.c.name == 'Wendy'</span>

<span class="sd">        The above expression will produce a :class:`.BinaryExpression`</span>
<span class="sd">        construct, where the left side is the :class:`.Column` object</span>
<span class="sd">        representing the ``name`` column, and the right side is a</span>
<span class="sd">        :class:`.BindParameter` representing the literal value::</span>

<span class="sd">            print(repr(expr.right))</span>
<span class="sd">            BindParameter('%(4327771088 name)s', 'Wendy', type_=String())</span>

<span class="sd">        The expression above will render SQL such as::</span>

<span class="sd">            user.name = :name_1</span>

<span class="sd">        Where the ``:name_1`` parameter name is an anonymous name.  The</span>
<span class="sd">        actual string ``Wendy`` is not in the rendered string, but is carried</span>
<span class="sd">        along where it is later used within statement execution.  If we</span>
<span class="sd">        invoke a statement like the following::</span>

<span class="sd">            stmt = select([users_table]).where(users_table.c.name == 'Wendy')</span>
<span class="sd">            result = connection.execute(stmt)</span>

<span class="sd">        We would see SQL logging output as::</span>

<span class="sd">            SELECT "user".id, "user".name</span>
<span class="sd">            FROM "user"</span>
<span class="sd">            WHERE "user".name = %(name_1)s</span>
<span class="sd">            {'name_1': 'Wendy'}</span>

<span class="sd">        Above, we see that ``Wendy`` is passed as a parameter to the database,</span>
<span class="sd">        while the placeholder ``:name_1`` is rendered in the appropriate form</span>
<span class="sd">        for the target database, in this case the PostgreSQL database.</span>

<span class="sd">        Similarly, :func:`.bindparam` is invoked automatically</span>
<span class="sd">        when working with :term:`CRUD` statements as far as the "VALUES"</span>
<span class="sd">        portion is concerned.   The :func:`.insert` construct produces an</span>
<span class="sd">        ``INSERT`` expression which will, at statement execution time,</span>
<span class="sd">        generate bound placeholders based on the arguments passed, as in::</span>

<span class="sd">            stmt = users_table.insert()</span>
<span class="sd">            result = connection.execute(stmt, name='Wendy')</span>

<span class="sd">        The above will produce SQL output as::</span>

<span class="sd">            INSERT INTO "user" (name) VALUES (%(name)s)</span>
<span class="sd">            {'name': 'Wendy'}</span>

<span class="sd">        The :class:`.Insert` construct, at compilation/execution time,</span>
<span class="sd">        rendered a single :func:`.bindparam` mirroring the column</span>
<span class="sd">        name ``name`` as a result of the single ``name`` parameter</span>
<span class="sd">        we passed to the :meth:`.Connection.execute` method.</span>

<span class="sd">        :param key:</span>
<span class="sd">          the key (e.g. the name) for this bind param.</span>
<span class="sd">          Will be used in the generated</span>
<span class="sd">          SQL statement for dialects that use named parameters.  This</span>
<span class="sd">          value may be modified when part of a compilation operation,</span>
<span class="sd">          if other :class:`BindParameter` objects exist with the same</span>
<span class="sd">          key, or if its length is too long and truncation is</span>
<span class="sd">          required.</span>

<span class="sd">        :param value:</span>
<span class="sd">          Initial value for this bind param.  Will be used at statement</span>
<span class="sd">          execution time as the value for this parameter passed to the</span>
<span class="sd">          DBAPI, if no other value is indicated to the statement execution</span>
<span class="sd">          method for this particular parameter name.  Defaults to ``None``.</span>

<span class="sd">        :param callable\_:</span>
<span class="sd">          A callable function that takes the place of "value".  The function</span>
<span class="sd">          will be called at statement execution time to determine the</span>
<span class="sd">          ultimate value.   Used for scenarios where the actual bind</span>
<span class="sd">          value cannot be determined at the point at which the clause</span>
<span class="sd">          construct is created, but embedded bind values are still desirable.</span>

<span class="sd">        :param type\_:</span>
<span class="sd">          A :class:`.TypeEngine` class or instance representing an optional</span>
<span class="sd">          datatype for this :func:`.bindparam`.  If not passed, a type</span>
<span class="sd">          may be determined automatically for the bind, based on the given</span>
<span class="sd">          value; for example, trivial Python types such as ``str``,</span>
<span class="sd">          ``int``, ``bool``</span>
<span class="sd">          may result in the :class:`.String`, :class:`.Integer` or</span>
<span class="sd">          :class:`.Boolean` types being automatically selected.</span>

<span class="sd">          The type of a :func:`.bindparam` is significant especially in that</span>
<span class="sd">          the type will apply pre-processing to the value before it is</span>
<span class="sd">          passed to the database.  For example, a :func:`.bindparam` which</span>
<span class="sd">          refers to a datetime value, and is specified as holding the</span>
<span class="sd">          :class:`.DateTime` type, may apply conversion needed to the</span>
<span class="sd">          value (such as stringification on SQLite) before passing the value</span>
<span class="sd">          to the database.</span>

<span class="sd">        :param unique:</span>
<span class="sd">          if True, the key name of this :class:`.BindParameter` will be</span>
<span class="sd">          modified if another :class:`.BindParameter` of the same name</span>
<span class="sd">          already has been located within the containing</span>
<span class="sd">          expression.  This flag is used generally by the internals</span>
<span class="sd">          when producing so-called "anonymous" bound expressions, it</span>
<span class="sd">          isn't generally applicable to explicitly-named :func:`.bindparam`</span>
<span class="sd">          constructs.</span>

<span class="sd">        :param required:</span>
<span class="sd">          If ``True``, a value is required at execution time.  If not passed,</span>
<span class="sd">          it defaults to ``True`` if neither :paramref:`.bindparam.value`</span>
<span class="sd">          or :paramref:`.bindparam.callable` were passed.  If either of these</span>
<span class="sd">          parameters are present, then :paramref:`.bindparam.required`</span>
<span class="sd">          defaults to ``False``.</span>

<span class="sd">        :param quote:</span>
<span class="sd">          True if this parameter name requires quoting and is not</span>
<span class="sd">          currently known as a SQLAlchemy reserved word; this currently</span>
<span class="sd">          only applies to the Oracle backend, where bound names must</span>
<span class="sd">          sometimes be quoted.</span>

<span class="sd">        :param isoutparam:</span>
<span class="sd">          if True, the parameter should be treated like a stored procedure</span>
<span class="sd">          "OUT" parameter.  This applies to backends such as Oracle which</span>
<span class="sd">          support OUT parameters.</span>

<span class="sd">        :param expanding:</span>
<span class="sd">          if True, this parameter will be treated as an "expanding" parameter</span>
<span class="sd">          at execution time; the parameter value is expected to be a sequence,</span>
<span class="sd">          rather than a scalar value, and the string SQL statement will</span>
<span class="sd">          be transformed on a per-execution basis to accommodate the sequence</span>
<span class="sd">          with a variable number of parameter slots passed to the DBAPI.</span>
<span class="sd">          This is to allow statement caching to be used in conjunction with</span>
<span class="sd">          an IN clause.</span>

<span class="sd">          .. seealso::</span>

<span class="sd">            :meth:`.ColumnOperators.in_`</span>

<span class="sd">            :ref:`baked_in` - with baked queries</span>

<span class="sd">          .. note:: The "expanding" feature does not support "executemany"-</span>
<span class="sd">             style parameter sets.</span>

<span class="sd">          .. versionadded:: 1.2</span>

<span class="sd">          .. versionchanged:: 1.3 the "expanding" bound parameter feature now</span>
<span class="sd">             supports empty lists.</span>


<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`coretutorial_bind_param`</span>

<span class="sd">            :ref:`coretutorial_insert_expressions`</span>

<span class="sd">            :func:`.outparam`</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">ColumnClause</span><span class="p">):</span>
            <span class="n">type_</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">type</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">key</span>
        <span class="k">if</span> <span class="n">required</span> <span class="ow">is</span> <span class="n">NO_ARG</span><span class="p">:</span>
            <span class="n">required</span> <span class="o">=</span> <span class="n">value</span> <span class="ow">is</span> <span class="n">NO_ARG</span> <span class="ow">and</span> <span class="n">callable_</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="n">NO_ARG</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">quote</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">quoted_name</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">quote</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">unique</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">_anonymous_label</span><span class="p">(</span>
                <span class="s2">"</span><span class="si">%%</span><span class="s2">(</span><span class="si">%d</span><span class="s2"> </span><span class="si">%s</span><span class="s2">)s"</span>
                <span class="o">%</span> <span class="p">(</span>
                    <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
                    <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">"[%\(\) \$]+"</span><span class="p">,</span> <span class="s2">"_"</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">"_"</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="k">else</span> <span class="s2">"param"</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span> <span class="ow">or</span> <span class="n">_anonymous_label</span><span class="p">(</span><span class="s2">"</span><span class="si">%%</span><span class="s2">(</span><span class="si">%d</span><span class="s2"> param)s"</span> <span class="o">%</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="c1"># identifying key that won't change across</span>
        <span class="c1"># clones, used to identify the bind's logical</span>
        <span class="c1"># identity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_identifying_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span>

        <span class="c1"># key that was passed in the first place, used to</span>
        <span class="c1"># generate new keys</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orig_key</span> <span class="o">=</span> <span class="n">key</span> <span class="ow">or</span> <span class="s2">"param"</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">unique</span> <span class="o">=</span> <span class="n">unique</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callable</span> <span class="o">=</span> <span class="n">callable_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isoutparam</span> <span class="o">=</span> <span class="n">isoutparam</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">required</span> <span class="o">=</span> <span class="n">required</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expanding</span> <span class="o">=</span> <span class="n">expanding</span>

        <span class="k">if</span> <span class="n">type_</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_compared_to_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">_compared_to_type</span><span class="o">.</span><span class="n">coerce_compared_value</span><span class="p">(</span>
                    <span class="n">_compared_to_operator</span><span class="p">,</span> <span class="n">value</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type_api</span><span class="o">.</span><span class="n">_resolve_value_to_type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">type_</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type_</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type_</span>

    <span class="k">def</span> <span class="nf">_with_expanding_in_types</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">types</span><span class="p">):</span>
        <span class="sd">"""Return a copy of this :class:`.BindParameter` in</span>
<span class="sd">        the context of an expanding IN against a tuple.</span>

<span class="sd">        """</span>
        <span class="n">cloned</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">()</span>
        <span class="n">cloned</span><span class="o">.</span><span class="n">_expanding_in_types</span> <span class="o">=</span> <span class="n">types</span>
        <span class="k">return</span> <span class="n">cloned</span>

    <span class="k">def</span> <span class="nf">_with_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">"""Return a copy of this :class:`.BindParameter` with the given value</span>
<span class="sd">        set.</span>
<span class="sd">        """</span>
        <span class="n">cloned</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">()</span>
        <span class="n">cloned</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">cloned</span><span class="o">.</span><span class="n">callable</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">cloned</span><span class="o">.</span><span class="n">required</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">cloned</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="n">type_api</span><span class="o">.</span><span class="n">NULLTYPE</span><span class="p">:</span>
            <span class="n">cloned</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type_api</span><span class="o">.</span><span class="n">_resolve_value_to_type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cloned</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">effective_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""Return the value of this bound parameter,</span>
<span class="sd">        taking into account if the ``callable`` parameter</span>
<span class="sd">        was set.</span>

<span class="sd">        The ``callable`` value will be evaluated</span>
<span class="sd">        and returned if present, else ``value``.</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">callable</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">callable</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">_clone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">ClauseElement</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique</span><span class="p">:</span>
            <span class="n">c</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">_anonymous_label</span><span class="p">(</span>
                <span class="s2">"</span><span class="si">%%</span><span class="s2">(</span><span class="si">%d</span><span class="s2"> </span><span class="si">%s</span><span class="s2">)s"</span> <span class="o">%</span> <span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">c</span><span class="o">.</span><span class="n">_orig_key</span> <span class="ow">or</span> <span class="s2">"param"</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">c</span>

    <span class="k">def</span> <span class="nf">_convert_to_unique</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unique</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">_anonymous_label</span><span class="p">(</span>
                <span class="s2">"</span><span class="si">%%</span><span class="s2">(</span><span class="si">%d</span><span class="s2"> </span><span class="si">%s</span><span class="s2">)s"</span> <span class="o">%</span> <span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_key</span> <span class="ow">or</span> <span class="s2">"param"</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">"""Compare this :class:`BindParameter` to the given</span>
<span class="sd">        clause."""</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BindParameter</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">_compare_type_affinity</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">callable</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">callable</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""execute a deferred value for serialization purposes."""</span>

        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">callable</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">callable</span><span class="p">()</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">"callable"</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">"value"</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"unique"</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">state</span><span class="p">[</span><span class="s2">"key"</span><span class="p">]</span> <span class="o">=</span> <span class="n">_anonymous_label</span><span class="p">(</span>
                <span class="s2">"</span><span class="si">%%</span><span class="s2">(</span><span class="si">%d</span><span class="s2"> </span><span class="si">%s</span><span class="s2">)s"</span> <span class="o">%</span> <span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">state</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">"_orig_key"</span><span class="p">,</span> <span class="s2">"param"</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">"BindParameter(</span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">, type_=</span><span class="si">%r</span><span class="s2">)"</span> <span class="o">%</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
        <span class="p">)</span>


<span class="k">class</span> <span class="nc">TypeClause</span><span class="p">(</span><span class="n">ClauseElement</span><span class="p">):</span>
    <span class="sd">"""Handle a type keyword in a SQL statement.</span>

<span class="sd">    Used by the ``Case`` statement.</span>

<span class="sd">    """</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s2">"typeclause"</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type_</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type_</span>


<span class="k">class</span> <span class="nc">TextClause</span><span class="p">(</span><span class="n">Executable</span><span class="p">,</span> <span class="n">ClauseElement</span><span class="p">):</span>
    <span class="sd">"""Represent a literal SQL text fragment.</span>

<span class="sd">    E.g.::</span>

<span class="sd">        from sqlalchemy import text</span>

<span class="sd">        t = text("SELECT * FROM users")</span>
<span class="sd">        result = connection.execute(t)</span>


<span class="sd">    The :class:`.Text` construct is produced using the :func:`.text`</span>
<span class="sd">    function; see that function for full documentation.</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :func:`.text`</span>

<span class="sd">    """</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s2">"textclause"</span>

    <span class="n">_bind_params_regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">"(?&lt;![:\w\x5c]):(\w+)(?!:)"</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">UNICODE</span><span class="p">)</span>
    <span class="n">_execution_options</span> <span class="o">=</span> <span class="n">Executable</span><span class="o">.</span><span class="n">_execution_options</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
        <span class="p">{</span><span class="s2">"autocommit"</span><span class="p">:</span> <span class="n">PARSE_AUTOCOMMIT</span><span class="p">}</span>
    <span class="p">)</span>
    <span class="n">_is_implicitly_boolean</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># support use in select.where(), query.filter()</span>
        <span class="k">return</span> <span class="n">and_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_select_iterable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">,)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">selectable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># allows text() to be considered by</span>
        <span class="c1"># _interpret_as_from</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="n">_hide_froms</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># help in those cases where text() is</span>
    <span class="c1"># interpreted in a column expression situation</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">_label</span> <span class="o">=</span> <span class="n">_resolve_label</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">_allow_label_resolve</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">bind</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bind</span> <span class="o">=</span> <span class="n">bind</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bindparams</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">def</span> <span class="nf">repl</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bindparams</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">BindParameter</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">return</span> <span class="s2">":</span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># scan the string and search for bind parameter names, add them</span>
        <span class="c1"># to the list of bindparams</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bind_params_regex</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">repl</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="nd">@util</span><span class="o">.</span><span class="n">deprecated_params</span><span class="p">(</span>
        <span class="n">autocommit</span><span class="o">=</span><span class="p">(</span>
            <span class="s2">"0.6"</span><span class="p">,</span>
            <span class="s2">"The :paramref:`.text.autocommit` parameter is deprecated and "</span>
            <span class="s2">"will be removed in a future release.  Please use the "</span>
            <span class="s2">":paramref:`.Connection.execution_options.autocommit` parameter "</span>
            <span class="s2">"in conjunction with the :meth:`.Executable.execution_options` "</span>
            <span class="s2">"method."</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">bindparams</span><span class="o">=</span><span class="p">(</span>
            <span class="s2">"0.9"</span><span class="p">,</span>
            <span class="s2">"The :paramref:`.text.bindparams` parameter "</span>
            <span class="s2">"is deprecated and will be removed in a future release.  Please "</span>
            <span class="s2">"refer to the :meth:`.TextClause.bindparams` method."</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">typemap</span><span class="o">=</span><span class="p">(</span>
            <span class="s2">"0.9"</span><span class="p">,</span>
            <span class="s2">"The :paramref:`.text.typemap` parameter is "</span>
            <span class="s2">"deprecated and will be removed in a future release.  Please "</span>
            <span class="s2">"refer to the :meth:`.TextClause.columns` method."</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">)</span>
    <span class="nd">@_document_text_coercion</span><span class="p">(</span><span class="s2">"text"</span><span class="p">,</span> <span class="s2">":func:`.text`"</span><span class="p">,</span> <span class="s2">":paramref:`.text.text`"</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_create_text</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">bind</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bindparams</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">typemap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">autocommit</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Construct a new :class:`.TextClause` clause, representing</span>
<span class="sd">        a textual SQL string directly.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            from sqlalchemy import text</span>

<span class="sd">            t = text("SELECT * FROM users")</span>
<span class="sd">            result = connection.execute(t)</span>

<span class="sd">        The advantages :func:`.text` provides over a plain string are</span>
<span class="sd">        backend-neutral support for bind parameters, per-statement</span>
<span class="sd">        execution options, as well as</span>
<span class="sd">        bind parameter and result-column typing behavior, allowing</span>
<span class="sd">        SQLAlchemy type constructs to play a role when executing</span>
<span class="sd">        a statement that is specified literally.  The construct can also</span>
<span class="sd">        be provided with a ``.c`` collection of column elements, allowing</span>
<span class="sd">        it to be embedded in other SQL expression constructs as a subquery.</span>

<span class="sd">        Bind parameters are specified by name, using the format ``:name``.</span>
<span class="sd">        E.g.::</span>

<span class="sd">            t = text("SELECT * FROM users WHERE id=:user_id")</span>
<span class="sd">            result = connection.execute(t, user_id=12)</span>

<span class="sd">        For SQL statements where a colon is required verbatim, as within</span>
<span class="sd">        an inline string, use a backslash to escape::</span>

<span class="sd">            t = text("SELECT * FROM users WHERE name='\:username'")</span>

<span class="sd">        The :class:`.TextClause` construct includes methods which can</span>
<span class="sd">        provide information about the bound parameters as well as the column</span>
<span class="sd">        values which would be returned from the textual statement, assuming</span>
<span class="sd">        it's an executable SELECT type of statement.  The</span>
<span class="sd">        :meth:`.TextClause.bindparams` method is used to provide bound</span>
<span class="sd">        parameter detail, and :meth:`.TextClause.columns` method allows</span>
<span class="sd">        specification of return columns including names and types::</span>

<span class="sd">            t = text("SELECT * FROM users WHERE id=:user_id").\</span>
<span class="sd">                    bindparams(user_id=7).\</span>
<span class="sd">                    columns(id=Integer, name=String)</span>

<span class="sd">            for id, name in connection.execute(t):</span>
<span class="sd">                print(id, name)</span>

<span class="sd">        The :func:`.text` construct is used in cases when</span>
<span class="sd">        a literal string SQL fragment is specified as part of a larger query,</span>
<span class="sd">        such as for the WHERE clause of a SELECT statement::</span>

<span class="sd">            s = select([users.c.id, users.c.name]).where(text("id=:user_id"))</span>
<span class="sd">            result = connection.execute(s, user_id=12)</span>

<span class="sd">        :func:`.text` is also used for the construction</span>
<span class="sd">        of a full, standalone statement using plain text.</span>
<span class="sd">        As such, SQLAlchemy refers</span>
<span class="sd">        to it as an :class:`.Executable` object, and it supports</span>
<span class="sd">        the :meth:`Executable.execution_options` method.  For example,</span>
<span class="sd">        a :func:`.text` construct that should be subject to "autocommit"</span>
<span class="sd">        can be set explicitly so using the</span>
<span class="sd">        :paramref:`.Connection.execution_options.autocommit` option::</span>

<span class="sd">            t = text("EXEC my_procedural_thing()").\</span>
<span class="sd">                    execution_options(autocommit=True)</span>

<span class="sd">        Note that SQLAlchemy's usual "autocommit" behavior applies to</span>
<span class="sd">        :func:`.text` constructs implicitly - that is, statements which begin</span>
<span class="sd">        with a phrase such as ``INSERT``, ``UPDATE``, ``DELETE``,</span>
<span class="sd">        or a variety of other phrases specific to certain backends, will</span>
<span class="sd">        be eligible for autocommit if no transaction is in progress.</span>

<span class="sd">        :param text:</span>
<span class="sd">          the text of the SQL statement to be created.  use ``:&lt;param&gt;``</span>
<span class="sd">          to specify bind parameters; they will be compiled to their</span>
<span class="sd">          engine-specific format.</span>

<span class="sd">        :param autocommit: whether or not to set the "autocommit" execution</span>
<span class="sd">          option for this :class:`.TextClause` object.</span>

<span class="sd">        :param bind:</span>
<span class="sd">          an optional connection or engine to be used for this text query.</span>

<span class="sd">        :param bindparams:</span>
<span class="sd">          A list of :func:`.bindparam` instances used to</span>
<span class="sd">          provide information about parameters embedded in the statement.</span>

<span class="sd">          E.g.::</span>

<span class="sd">              stmt = text("SELECT * FROM table WHERE id=:id",</span>
<span class="sd">                        bindparams=[bindparam('id', value=5, type_=Integer)])</span>

<span class="sd">        :param typemap:</span>
<span class="sd">          A dictionary mapping the names of columns represented in the columns</span>
<span class="sd">          clause of a ``SELECT`` statement to type objects.</span>

<span class="sd">          E.g.::</span>

<span class="sd">              stmt = text("SELECT * FROM table",</span>
<span class="sd">                            typemap={'id': Integer, 'name': String},</span>
<span class="sd">                        )</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`sqlexpression_text` - in the Core tutorial</span>

<span class="sd">            :ref:`orm_tutorial_literal_sql` - in the ORM tutorial</span>

<span class="sd">        """</span>
        <span class="n">stmt</span> <span class="o">=</span> <span class="n">TextClause</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">bind</span><span class="o">=</span><span class="n">bind</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bindparams</span><span class="p">:</span>
            <span class="n">stmt</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">bindparams</span><span class="p">(</span><span class="o">*</span><span class="n">bindparams</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">typemap</span><span class="p">:</span>
            <span class="n">stmt</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">columns</span><span class="p">(</span><span class="o">**</span><span class="n">typemap</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">autocommit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stmt</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">execution_options</span><span class="p">(</span><span class="n">autocommit</span><span class="o">=</span><span class="n">autocommit</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">stmt</span>

    <span class="nd">@_generative</span>
    <span class="k">def</span> <span class="nf">bindparams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">binds</span><span class="p">,</span> <span class="o">**</span><span class="n">names_to_values</span><span class="p">):</span>
        <span class="sd">"""Establish the values and/or types of bound parameters within</span>
<span class="sd">        this :class:`.TextClause` construct.</span>

<span class="sd">        Given a text construct such as::</span>

<span class="sd">            from sqlalchemy import text</span>
<span class="sd">            stmt = text("SELECT id, name FROM user WHERE name=:name "</span>
<span class="sd">                        "AND timestamp=:timestamp")</span>

<span class="sd">        the :meth:`.TextClause.bindparams` method can be used to establish</span>
<span class="sd">        the initial value of ``:name`` and ``:timestamp``,</span>
<span class="sd">        using simple keyword arguments::</span>

<span class="sd">            stmt = stmt.bindparams(name='jack',</span>
<span class="sd">                        timestamp=datetime.datetime(2012, 10, 8, 15, 12, 5))</span>

<span class="sd">        Where above, new :class:`.BindParameter` objects</span>
<span class="sd">        will be generated with the names ``name`` and ``timestamp``, and</span>
<span class="sd">        values of ``jack`` and ``datetime.datetime(2012, 10, 8, 15, 12, 5)``,</span>
<span class="sd">        respectively.  The types will be</span>
<span class="sd">        inferred from the values given, in this case :class:`.String` and</span>
<span class="sd">        :class:`.DateTime`.</span>

<span class="sd">        When specific typing behavior is needed, the positional ``*binds``</span>
<span class="sd">        argument can be used in which to specify :func:`.bindparam` constructs</span>
<span class="sd">        directly.  These constructs must include at least the ``key``</span>
<span class="sd">        argument, then an optional value and type::</span>

<span class="sd">            from sqlalchemy import bindparam</span>
<span class="sd">            stmt = stmt.bindparams(</span>
<span class="sd">                            bindparam('name', value='jack', type_=String),</span>
<span class="sd">                            bindparam('timestamp', type_=DateTime)</span>
<span class="sd">                        )</span>

<span class="sd">        Above, we specified the type of :class:`.DateTime` for the</span>
<span class="sd">        ``timestamp`` bind, and the type of :class:`.String` for the ``name``</span>
<span class="sd">        bind.  In the case of ``name`` we also set the default value of</span>
<span class="sd">        ``"jack"``.</span>

<span class="sd">        Additional bound parameters can be supplied at statement execution</span>
<span class="sd">        time, e.g.::</span>

<span class="sd">            result = connection.execute(stmt,</span>
<span class="sd">                        timestamp=datetime.datetime(2012, 10, 8, 15, 12, 5))</span>

<span class="sd">        The :meth:`.TextClause.bindparams` method can be called repeatedly,</span>
<span class="sd">        where it will re-use existing :class:`.BindParameter` objects to add</span>
<span class="sd">        new information.  For example, we can call</span>
<span class="sd">        :meth:`.TextClause.bindparams` first with typing information, and a</span>
<span class="sd">        second time with value information, and it will be combined::</span>

<span class="sd">            stmt = text("SELECT id, name FROM user WHERE name=:name "</span>
<span class="sd">                        "AND timestamp=:timestamp")</span>
<span class="sd">            stmt = stmt.bindparams(</span>
<span class="sd">                bindparam('name', type_=String),</span>
<span class="sd">                bindparam('timestamp', type_=DateTime)</span>
<span class="sd">            )</span>
<span class="sd">            stmt = stmt.bindparams(</span>
<span class="sd">                name='jack',</span>
<span class="sd">                timestamp=datetime.datetime(2012, 10, 8, 15, 12, 5)</span>
<span class="sd">            )</span>

<span class="sd">        The :meth:`.TextClause.bindparams` method also supports the concept of</span>
<span class="sd">        **unique** bound parameters.  These are parameters that are</span>
<span class="sd">        "uniquified" on name at statement compilation time, so that  multiple</span>
<span class="sd">        :func:`.text` constructs may be combined together without the names</span>
<span class="sd">        conflicting.  To use this feature, specify the</span>
<span class="sd">        :paramref:`.BindParameter.unique` flag on each :func:`.bindparam`</span>
<span class="sd">        object::</span>

<span class="sd">            stmt1 = text("select id from table where name=:name").bindparams(</span>
<span class="sd">                bindparam("name", value='name1', unique=True)</span>
<span class="sd">            )</span>
<span class="sd">            stmt2 = text("select id from table where name=:name").bindparams(</span>
<span class="sd">                bindparam("name", value='name2', unique=True)</span>
<span class="sd">            )</span>

<span class="sd">            union = union_all(</span>
<span class="sd">                stmt1.columns(column("id")),</span>
<span class="sd">                stmt2.columns(column("id"))</span>
<span class="sd">            )</span>

<span class="sd">        The above statement will render as::</span>

<span class="sd">            select id from table where name=:name_1</span>
<span class="sd">            UNION ALL select id from table where name=:name_2</span>

<span class="sd">        .. versionadded:: 1.3.11  Added support for the</span>
<span class="sd">           :paramref:`.BindParameter.unique` flag to work with :func:`.text`</span>
<span class="sd">           constructs.</span>

<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bindparams</span> <span class="o">=</span> <span class="n">new_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bindparams</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">bind</span> <span class="ow">in</span> <span class="n">binds</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># the regex used for text() currently will not match</span>
                <span class="c1"># a unique/anonymous key in any case, so use the _orig_key</span>
                <span class="c1"># so that a text() construct can support unique parameters</span>
                <span class="n">existing</span> <span class="o">=</span> <span class="n">new_params</span><span class="p">[</span><span class="n">bind</span><span class="o">.</span><span class="n">_orig_key</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="n">util</span><span class="o">.</span><span class="n">raise_</span><span class="p">(</span>
                    <span class="n">exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
                        <span class="s2">"This text() construct doesn't define a "</span>
                        <span class="s2">"bound parameter named </span><span class="si">%r</span><span class="s2">"</span> <span class="o">%</span> <span class="n">bind</span><span class="o">.</span><span class="n">_orig_key</span>
                    <span class="p">),</span>
                    <span class="n">replace_context</span><span class="o">=</span><span class="n">err</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_params</span><span class="p">[</span><span class="n">existing</span><span class="o">.</span><span class="n">_orig_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">bind</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">names_to_values</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">existing</span> <span class="o">=</span> <span class="n">new_params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="n">util</span><span class="o">.</span><span class="n">raise_</span><span class="p">(</span>
                    <span class="n">exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
                        <span class="s2">"This text() construct doesn't define a "</span>
                        <span class="s2">"bound parameter named </span><span class="si">%r</span><span class="s2">"</span> <span class="o">%</span> <span class="n">key</span>
                    <span class="p">),</span>
                    <span class="n">replace_context</span><span class="o">=</span><span class="n">err</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">existing</span><span class="o">.</span><span class="n">_with_value</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">dependencies</span><span class="p">(</span><span class="s2">"sqlalchemy.sql.selectable"</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selectable</span><span class="p">,</span> <span class="o">*</span><span class="n">cols</span><span class="p">,</span> <span class="o">**</span><span class="n">types</span><span class="p">):</span>
        <span class="sd">"""Turn this :class:`.TextClause` object into a :class:`.TextAsFrom`</span>
<span class="sd">        object that can be embedded into another statement.</span>

<span class="sd">        This function essentially bridges the gap between an entirely</span>
<span class="sd">        textual SELECT statement and the SQL expression language concept</span>
<span class="sd">        of a "selectable"::</span>

<span class="sd">            from sqlalchemy.sql import column, text</span>

<span class="sd">            stmt = text("SELECT id, name FROM some_table")</span>
<span class="sd">            stmt = stmt.columns(column('id'), column('name')).alias('st')</span>

<span class="sd">            stmt = select([mytable]).\</span>
<span class="sd">                    select_from(</span>
<span class="sd">                        mytable.join(stmt, mytable.c.name == stmt.c.name)</span>
<span class="sd">                    ).where(stmt.c.id &gt; 5)</span>

<span class="sd">        Above, we pass a series of :func:`.column` elements to the</span>
<span class="sd">        :meth:`.TextClause.columns` method positionally.  These :func:`.column`</span>
<span class="sd">        elements now become first class elements upon the :attr:`.TextAsFrom.c`</span>
<span class="sd">        column collection, just like any other selectable.</span>

<span class="sd">        The column expressions we pass to :meth:`.TextClause.columns` may</span>
<span class="sd">        also be typed; when we do so, these :class:`.TypeEngine` objects become</span>
<span class="sd">        the effective return type of the column, so that SQLAlchemy's</span>
<span class="sd">        result-set-processing systems may be used on the return values.</span>
<span class="sd">        This is often needed for types such as date or boolean types, as well</span>
<span class="sd">        as for unicode processing on some dialect configurations::</span>

<span class="sd">            stmt = text("SELECT id, name, timestamp FROM some_table")</span>
<span class="sd">            stmt = stmt.columns(</span>
<span class="sd">                        column('id', Integer),</span>
<span class="sd">                        column('name', Unicode),</span>
<span class="sd">                        column('timestamp', DateTime)</span>
<span class="sd">                    )</span>

<span class="sd">            for id, name, timestamp in connection.execute(stmt):</span>
<span class="sd">                print(id, name, timestamp)</span>

<span class="sd">        As a shortcut to the above syntax, keyword arguments referring to</span>
<span class="sd">        types alone may be used, if only type conversion is needed::</span>

<span class="sd">            stmt = text("SELECT id, name, timestamp FROM some_table")</span>
<span class="sd">            stmt = stmt.columns(</span>
<span class="sd">                        id=Integer,</span>
<span class="sd">                        name=Unicode,</span>
<span class="sd">                        timestamp=DateTime</span>
<span class="sd">                    )</span>

<span class="sd">            for id, name, timestamp in connection.execute(stmt):</span>
<span class="sd">                print(id, name, timestamp)</span>

<span class="sd">        The positional form of :meth:`.TextClause.columns` also provides the</span>
<span class="sd">        unique feature of **positional column targeting**, which is</span>
<span class="sd">        particularly useful when using the ORM with complex textual queries. If</span>
<span class="sd">        we specify the columns from our model to :meth:`.TextClause.columns`,</span>
<span class="sd">        the result set will match to those columns positionally, meaning the</span>
<span class="sd">        name or origin of the column in the textual SQL doesn't matter::</span>

<span class="sd">            stmt = text("SELECT users.id, addresses.id, users.id, "</span>
<span class="sd">                 "users.name, addresses.email_address AS email "</span>
<span class="sd">                 "FROM users JOIN addresses ON users.id=addresses.user_id "</span>
<span class="sd">                 "WHERE users.id = 1").columns(</span>
<span class="sd">                    User.id,</span>
<span class="sd">                    Address.id,</span>
<span class="sd">                    Address.user_id,</span>
<span class="sd">                    User.name,</span>
<span class="sd">                    Address.email_address</span>
<span class="sd">                 )</span>

<span class="sd">            query = session.query(User).from_statement(stmt).options(</span>
<span class="sd">                contains_eager(User.addresses))</span>

<span class="sd">        .. versionadded:: 1.1 the :meth:`.TextClause.columns` method now</span>
<span class="sd">           offers positional column targeting in the result set when</span>
<span class="sd">           the column expressions are passed purely positionally.</span>

<span class="sd">        The :meth:`.TextClause.columns` method provides a direct</span>
<span class="sd">        route to calling :meth:`.FromClause.alias` as well as</span>
<span class="sd">        :meth:`.SelectBase.cte` against a textual SELECT statement::</span>

<span class="sd">            stmt = stmt.columns(id=Integer, name=String).cte('st')</span>

<span class="sd">            stmt = select([sometable]).where(sometable.c.id == stmt.c.id)</span>

<span class="sd">        .. versionadded:: 0.9.0 :func:`.text` can now be converted into a</span>
<span class="sd">           fully featured "selectable" construct using the</span>
<span class="sd">           :meth:`.TextClause.columns` method.</span>


<span class="sd">        """</span>

        <span class="n">positional_input_cols</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">ColumnClause</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">key</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">key</span> <span class="ow">in</span> <span class="n">types</span>
            <span class="k">else</span> <span class="n">col</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span>
        <span class="p">]</span>
        <span class="n">keyed_input_cols</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">ColumnClause</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">type_</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">type_</span> <span class="ow">in</span> <span class="n">types</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="n">selectable</span><span class="o">.</span><span class="n">TextAsFrom</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">positional_input_cols</span> <span class="o">+</span> <span class="n">keyed_input_cols</span><span class="p">,</span>
            <span class="n">positional</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">positional_input_cols</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">keyed_input_cols</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">type_api</span><span class="o">.</span><span class="n">NULLTYPE</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">comparator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">comparator_factory</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">self_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">against</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">against</span> <span class="ow">is</span> <span class="n">operators</span><span class="o">.</span><span class="n">in_op</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Grouping</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_copy_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">_clone</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bindparams</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">clone</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">))</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bindparams</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bindparams</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">TextClause</span><span class="p">)</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">text</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span>


<span class="k">class</span> <span class="nc">Null</span><span class="p">(</span><span class="n">ColumnElement</span><span class="p">):</span>
    <span class="sd">"""Represent the NULL keyword in a SQL statement.</span>

<span class="sd">    :class:`.Null` is accessed as a constant via the</span>
<span class="sd">    :func:`.null` function.</span>

<span class="sd">    """</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s2">"null"</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">memoized_property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">type_api</span><span class="o">.</span><span class="n">NULLTYPE</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_instance</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">"""Return a constant :class:`.Null` construct."""</span>

        <span class="k">return</span> <span class="n">Null</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Null</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">False_</span><span class="p">(</span><span class="n">ColumnElement</span><span class="p">):</span>
    <span class="sd">"""Represent the ``false`` keyword, or equivalent, in a SQL statement.</span>

<span class="sd">    :class:`.False_` is accessed as a constant via the</span>
<span class="sd">    :func:`.false` function.</span>

<span class="sd">    """</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s2">"false"</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">memoized_property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">type_api</span><span class="o">.</span><span class="n">BOOLEANTYPE</span>

    <span class="k">def</span> <span class="nf">_negate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">True_</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_instance</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">"""Return a :class:`.False_` construct.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            &gt;&gt;&gt; from sqlalchemy import false</span>
<span class="sd">            &gt;&gt;&gt; print(select([t.c.x]).where(false()))</span>
<span class="sd">            SELECT x FROM t WHERE false</span>

<span class="sd">        A backend which does not support true/false constants will render as</span>
<span class="sd">        an expression against 1 or 0::</span>

<span class="sd">            &gt;&gt;&gt; print(select([t.c.x]).where(false()))</span>
<span class="sd">            SELECT x FROM t WHERE 0 = 1</span>

<span class="sd">        The :func:`.true` and :func:`.false` constants also feature</span>
<span class="sd">        "short circuit" operation within an :func:`.and_` or :func:`.or_`</span>
<span class="sd">        conjunction::</span>

<span class="sd">            &gt;&gt;&gt; print(select([t.c.x]).where(or_(t.c.x &gt; 5, true())))</span>
<span class="sd">            SELECT x FROM t WHERE true</span>

<span class="sd">            &gt;&gt;&gt; print(select([t.c.x]).where(and_(t.c.x &gt; 5, false())))</span>
<span class="sd">            SELECT x FROM t WHERE false</span>

<span class="sd">        .. versionchanged:: 0.9 :func:`.true` and :func:`.false` feature</span>
<span class="sd">           better integrated behavior within conjunctions and on dialects</span>
<span class="sd">           that don't support true/false constants.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :func:`.true`</span>

<span class="sd">        """</span>

        <span class="k">return</span> <span class="n">False_</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">False_</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">True_</span><span class="p">(</span><span class="n">ColumnElement</span><span class="p">):</span>
    <span class="sd">"""Represent the ``true`` keyword, or equivalent, in a SQL statement.</span>

<span class="sd">    :class:`.True_` is accessed as a constant via the</span>
<span class="sd">    :func:`.true` function.</span>

<span class="sd">    """</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s2">"true"</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">memoized_property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">type_api</span><span class="o">.</span><span class="n">BOOLEANTYPE</span>

    <span class="k">def</span> <span class="nf">_negate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">False_</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_ifnone</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_instance</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">other</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_instance</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">"""Return a constant :class:`.True_` construct.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            &gt;&gt;&gt; from sqlalchemy import true</span>
<span class="sd">            &gt;&gt;&gt; print(select([t.c.x]).where(true()))</span>
<span class="sd">            SELECT x FROM t WHERE true</span>

<span class="sd">        A backend which does not support true/false constants will render as</span>
<span class="sd">        an expression against 1 or 0::</span>

<span class="sd">            &gt;&gt;&gt; print(select([t.c.x]).where(true()))</span>
<span class="sd">            SELECT x FROM t WHERE 1 = 1</span>

<span class="sd">        The :func:`.true` and :func:`.false` constants also feature</span>
<span class="sd">        "short circuit" operation within an :func:`.and_` or :func:`.or_`</span>
<span class="sd">        conjunction::</span>

<span class="sd">            &gt;&gt;&gt; print(select([t.c.x]).where(or_(t.c.x &gt; 5, true())))</span>
<span class="sd">            SELECT x FROM t WHERE true</span>

<span class="sd">            &gt;&gt;&gt; print(select([t.c.x]).where(and_(t.c.x &gt; 5, false())))</span>
<span class="sd">            SELECT x FROM t WHERE false</span>

<span class="sd">        .. versionchanged:: 0.9 :func:`.true` and :func:`.false` feature</span>
<span class="sd">           better integrated behavior within conjunctions and on dialects</span>
<span class="sd">           that don't support true/false constants.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :func:`.false`</span>

<span class="sd">        """</span>

        <span class="k">return</span> <span class="n">True_</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">True_</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ClauseList</span><span class="p">(</span><span class="n">ClauseElement</span><span class="p">):</span>
    <span class="sd">"""Describe a list of clauses, separated by an operator.</span>

<span class="sd">    By default, is comma-separated, such as a column listing.</span>

<span class="sd">    """</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s2">"clauselist"</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">clauses</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"operator"</span><span class="p">,</span> <span class="n">operators</span><span class="o">.</span><span class="n">comma_op</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">group</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"group"</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">group_contents</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"group_contents"</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tuple_values</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"_tuple_values"</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">text_converter</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span>
            <span class="s2">"_literal_as_text"</span><span class="p">,</span> <span class="n">_expression_literal_as_text</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_contents</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clauses</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">text_converter</span><span class="p">(</span><span class="n">clause</span><span class="p">)</span><span class="o">.</span><span class="n">self_group</span><span class="p">(</span><span class="n">against</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">clause</span> <span class="ow">in</span> <span class="n">clauses</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clauses</span> <span class="o">=</span> <span class="p">[</span><span class="n">text_converter</span><span class="p">(</span><span class="n">clause</span><span class="p">)</span> <span class="k">for</span> <span class="n">clause</span> <span class="ow">in</span> <span class="n">clauses</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_implicitly_boolean</span> <span class="o">=</span> <span class="n">operators</span><span class="o">.</span><span class="n">is_boolean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_select_iterable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clause</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_contents</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clauses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">_literal_as_text</span><span class="p">(</span><span class="n">clause</span><span class="p">)</span><span class="o">.</span><span class="n">self_group</span><span class="p">(</span><span class="n">against</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clauses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_literal_as_text</span><span class="p">(</span><span class="n">clause</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_copy_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">_clone</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clauses</span> <span class="o">=</span> <span class="p">[</span><span class="n">clone</span><span class="p">(</span><span class="n">clause</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span> <span class="k">for</span> <span class="n">clause</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clauses</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clauses</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_from_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">_from_objects</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clauses</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">self_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">against</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">group</span> <span class="ow">and</span> <span class="n">operators</span><span class="o">.</span><span class="n">is_precedent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span> <span class="n">against</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Grouping</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">"""Compare this :class:`.ClauseList` to the given :class:`.ClauseList`,</span>
<span class="sd">        including a comparison of all the clause items.</span>

<span class="sd">        """</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ClauseList</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clauses</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ClauseList</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="ow">is</span> <span class="n">other</span><span class="o">.</span><span class="n">operator</span>
        <span class="p">):</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="ow">in</span> <span class="p">(</span><span class="n">operators</span><span class="o">.</span><span class="n">and_</span><span class="p">,</span> <span class="n">operators</span><span class="o">.</span><span class="n">or_</span><span class="p">):</span>
                <span class="n">completed</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">clause</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">clauses</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">other_clause</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span>
                        <span class="n">completed</span>
                    <span class="p">):</span>
                        <span class="k">if</span> <span class="n">clause</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">other_clause</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
                            <span class="n">completed</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">other_clause</span><span class="p">)</span>
                            <span class="k">break</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">completed</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clauses</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">clauses</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">clauses</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
                        <span class="k">return</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>


<span class="k">class</span> <span class="nc">BooleanClauseList</span><span class="p">(</span><span class="n">ClauseList</span><span class="p">,</span> <span class="n">ColumnElement</span><span class="p">):</span>
    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s2">"clauselist"</span>

    <span class="n">_tuple_values</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">"BooleanClauseList has a private constructor"</span>
        <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_construct</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">continue_on</span><span class="p">,</span> <span class="n">skip_on</span><span class="p">,</span> <span class="o">*</span><span class="n">clauses</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="n">convert_clauses</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">clauses</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">_expression_literal_as_text</span><span class="p">(</span><span class="n">clause</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">clause</span> <span class="ow">in</span> <span class="n">util</span><span class="o">.</span><span class="n">coerce_generator_arg</span><span class="p">(</span><span class="n">clauses</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">clause</span> <span class="ow">in</span> <span class="n">clauses</span><span class="p">:</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clause</span><span class="p">,</span> <span class="n">continue_on</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clause</span><span class="p">,</span> <span class="n">skip_on</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">clause</span><span class="o">.</span><span class="n">self_group</span><span class="p">(</span><span class="n">against</span><span class="o">=</span><span class="n">operators</span><span class="o">.</span><span class="n">_asbool</span><span class="p">)</span>

            <span class="n">convert_clauses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clause</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">convert_clauses</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">convert_clauses</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">self_group</span><span class="p">(</span><span class="n">against</span><span class="o">=</span><span class="n">operators</span><span class="o">.</span><span class="n">_asbool</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">convert_clauses</span> <span class="ow">and</span> <span class="n">clauses</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">clauses</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">self_group</span><span class="p">(</span><span class="n">against</span><span class="o">=</span><span class="n">operators</span><span class="o">.</span><span class="n">_asbool</span><span class="p">)</span>

        <span class="n">convert_clauses</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">c</span><span class="o">.</span><span class="n">self_group</span><span class="p">(</span><span class="n">against</span><span class="o">=</span><span class="n">operator</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">convert_clauses</span>
        <span class="p">]</span>

        <span class="bp">self</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clauses</span> <span class="o">=</span> <span class="n">convert_clauses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">group</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">=</span> <span class="n">operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">group_contents</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type_api</span><span class="o">.</span><span class="n">BOOLEANTYPE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_implicitly_boolean</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">and_</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">clauses</span><span class="p">):</span>
        <span class="sd">"""Produce a conjunction of expressions joined by ``AND``.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            from sqlalchemy import and_</span>

<span class="sd">            stmt = select([users_table]).where(</span>
<span class="sd">                            and_(</span>
<span class="sd">                                users_table.c.name == 'wendy',</span>
<span class="sd">                                users_table.c.enrolled == True</span>
<span class="sd">                            )</span>
<span class="sd">                        )</span>

<span class="sd">        The :func:`.and_` conjunction is also available using the</span>
<span class="sd">        Python ``&amp;`` operator (though note that compound expressions</span>
<span class="sd">        need to be parenthesized in order to function with Python</span>
<span class="sd">        operator precedence behavior)::</span>

<span class="sd">            stmt = select([users_table]).where(</span>
<span class="sd">                            (users_table.c.name == 'wendy') &amp;</span>
<span class="sd">                            (users_table.c.enrolled == True)</span>
<span class="sd">                        )</span>

<span class="sd">        The :func:`.and_` operation is also implicit in some cases;</span>
<span class="sd">        the :meth:`.Select.where` method for example can be invoked multiple</span>
<span class="sd">        times against a statement, which will have the effect of each</span>
<span class="sd">        clause being combined using :func:`.and_`::</span>

<span class="sd">            stmt = select([users_table]).\</span>
<span class="sd">                        where(users_table.c.name == 'wendy').\</span>
<span class="sd">                        where(users_table.c.enrolled == True)</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :func:`.or_`</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_construct</span><span class="p">(</span><span class="n">operators</span><span class="o">.</span><span class="n">and_</span><span class="p">,</span> <span class="n">True_</span><span class="p">,</span> <span class="n">False_</span><span class="p">,</span> <span class="o">*</span><span class="n">clauses</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">or_</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">clauses</span><span class="p">):</span>
        <span class="sd">"""Produce a conjunction of expressions joined by ``OR``.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            from sqlalchemy import or_</span>

<span class="sd">            stmt = select([users_table]).where(</span>
<span class="sd">                            or_(</span>
<span class="sd">                                users_table.c.name == 'wendy',</span>
<span class="sd">                                users_table.c.name == 'jack'</span>
<span class="sd">                            )</span>
<span class="sd">                        )</span>

<span class="sd">        The :func:`.or_` conjunction is also available using the</span>
<span class="sd">        Python ``|`` operator (though note that compound expressions</span>
<span class="sd">        need to be parenthesized in order to function with Python</span>
<span class="sd">        operator precedence behavior)::</span>

<span class="sd">            stmt = select([users_table]).where(</span>
<span class="sd">                            (users_table.c.name == 'wendy') |</span>
<span class="sd">                            (users_table.c.name == 'jack')</span>
<span class="sd">                        )</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :func:`.and_`</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_construct</span><span class="p">(</span><span class="n">operators</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">False_</span><span class="p">,</span> <span class="n">True_</span><span class="p">,</span> <span class="o">*</span><span class="n">clauses</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_select_iterable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">,)</span>

    <span class="k">def</span> <span class="nf">self_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">against</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">clauses</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">BooleanClauseList</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">self_group</span><span class="p">(</span><span class="n">against</span><span class="o">=</span><span class="n">against</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_negate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ClauseList</span><span class="o">.</span><span class="n">_negate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<span class="n">and_</span> <span class="o">=</span> <span class="n">BooleanClauseList</span><span class="o">.</span><span class="n">and_</span>
<span class="n">or_</span> <span class="o">=</span> <span class="n">BooleanClauseList</span><span class="o">.</span><span class="n">or_</span>


<span class="k">class</span> <span class="nc">Tuple</span><span class="p">(</span><span class="n">ClauseList</span><span class="p">,</span> <span class="n">ColumnElement</span><span class="p">):</span>
    <span class="sd">"""Represent a SQL tuple."""</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">clauses</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">"""Return a :class:`.Tuple`.</span>

<span class="sd">        Main usage is to produce a composite IN construct using</span>
<span class="sd">        :meth:`.ColumnOperators.in_` ::</span>

<span class="sd">            from sqlalchemy import tuple_</span>

<span class="sd">            tuple_(table.c.col1, table.c.col2).in_(</span>
<span class="sd">                [(1, 2), (5, 12), (10, 19)]</span>
<span class="sd">            )</span>

<span class="sd">        .. versionchanged:: 1.3.6 Added support for SQLite IN tuples.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            The composite IN construct is not supported by all backends, and is</span>
<span class="sd">            currently known to work on PostgreSQL, MySQL, and SQLite.</span>
<span class="sd">            Unsupported backends will raise a subclass of</span>
<span class="sd">            :class:`~sqlalchemy.exc.DBAPIError` when such an expression is</span>
<span class="sd">            invoked.</span>

<span class="sd">        """</span>

        <span class="n">clauses</span> <span class="o">=</span> <span class="p">[</span><span class="n">_literal_as_binds</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">clauses</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_type_tuple</span> <span class="o">=</span> <span class="p">[</span><span class="n">arg</span><span class="o">.</span><span class="n">type</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">clauses</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span>
            <span class="s2">"type_"</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_type_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_tuple</span> <span class="k">else</span> <span class="n">type_api</span><span class="o">.</span><span class="n">NULLTYPE</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">Tuple</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">clauses</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_select_iterable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">,)</span>

    <span class="k">def</span> <span class="nf">_bind_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Tuple</span><span class="p">(</span>
            <span class="o">*</span><span class="p">[</span>
                <span class="n">BindParameter</span><span class="p">(</span>
                    <span class="kc">None</span><span class="p">,</span>
                    <span class="n">o</span><span class="p">,</span>
                    <span class="n">_compared_to_operator</span><span class="o">=</span><span class="n">operator</span><span class="p">,</span>
                    <span class="n">_compared_to_type</span><span class="o">=</span><span class="n">compared_to_type</span><span class="p">,</span>
                    <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">type_</span><span class="o">=</span><span class="n">type_</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">compared_to_type</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_tuple</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span><span class="o">.</span><span class="n">self_group</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">Case</span><span class="p">(</span><span class="n">ColumnElement</span><span class="p">):</span>
    <span class="sd">"""Represent a ``CASE`` expression.</span>

<span class="sd">    :class:`.Case` is produced using the :func:`.case` factory function,</span>
<span class="sd">    as in::</span>

<span class="sd">        from sqlalchemy import case</span>

<span class="sd">        stmt = select([users_table]).\</span>
<span class="sd">                    where(</span>
<span class="sd">                        case(</span>
<span class="sd">                            [</span>
<span class="sd">                                (users_table.c.name == 'wendy', 'W'),</span>
<span class="sd">                                (users_table.c.name == 'jack', 'J')</span>
<span class="sd">                            ],</span>
<span class="sd">                            else_='E'</span>
<span class="sd">                        )</span>
<span class="sd">                    )</span>

<span class="sd">    Details on :class:`.Case` usage is at :func:`.case`.</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :func:`.case`</span>

<span class="sd">    """</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s2">"case"</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">whens</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">else_</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Produce a ``CASE`` expression.</span>

<span class="sd">        The ``CASE`` construct in SQL is a conditional object that</span>
<span class="sd">        acts somewhat analogously to an "if/then" construct in other</span>
<span class="sd">        languages.  It returns an instance of :class:`.Case`.</span>

<span class="sd">        :func:`.case` in its usual form is passed a list of "when"</span>
<span class="sd">        constructs, that is, a list of conditions and results as tuples::</span>

<span class="sd">            from sqlalchemy import case</span>

<span class="sd">            stmt = select([users_table]).\</span>
<span class="sd">                        where(</span>
<span class="sd">                            case(</span>
<span class="sd">                                [</span>
<span class="sd">                                    (users_table.c.name == 'wendy', 'W'),</span>
<span class="sd">                                    (users_table.c.name == 'jack', 'J')</span>
<span class="sd">                                ],</span>
<span class="sd">                                else_='E'</span>
<span class="sd">                            )</span>
<span class="sd">                        )</span>

<span class="sd">        The above statement will produce SQL resembling::</span>

<span class="sd">            SELECT id, name FROM user</span>
<span class="sd">            WHERE CASE</span>
<span class="sd">                WHEN (name = :name_1) THEN :param_1</span>
<span class="sd">                WHEN (name = :name_2) THEN :param_2</span>
<span class="sd">                ELSE :param_3</span>
<span class="sd">            END</span>

<span class="sd">        When simple equality expressions of several values against a single</span>
<span class="sd">        parent column are needed, :func:`.case` also has a "shorthand" format</span>
<span class="sd">        used via the</span>
<span class="sd">        :paramref:`.case.value` parameter, which is passed a column</span>
<span class="sd">        expression to be compared.  In this form, the :paramref:`.case.whens`</span>
<span class="sd">        parameter is passed as a dictionary containing expressions to be</span>
<span class="sd">        compared against keyed to result expressions.  The statement below is</span>
<span class="sd">        equivalent to the preceding statement::</span>

<span class="sd">            stmt = select([users_table]).\</span>
<span class="sd">                        where(</span>
<span class="sd">                            case(</span>
<span class="sd">                                {"wendy": "W", "jack": "J"},</span>
<span class="sd">                                value=users_table.c.name,</span>
<span class="sd">                                else_='E'</span>
<span class="sd">                            )</span>
<span class="sd">                        )</span>

<span class="sd">        The values which are accepted as result values in</span>
<span class="sd">        :paramref:`.case.whens` as well as with :paramref:`.case.else_` are</span>
<span class="sd">        coerced from Python literals into :func:`.bindparam` constructs.</span>
<span class="sd">        SQL expressions, e.g. :class:`.ColumnElement` constructs, are accepted</span>
<span class="sd">        as well.  To coerce a literal string expression into a constant</span>
<span class="sd">        expression rendered inline, use the :func:`.literal_column` construct,</span>
<span class="sd">        as in::</span>

<span class="sd">            from sqlalchemy import case, literal_column</span>

<span class="sd">            case(</span>
<span class="sd">                [</span>
<span class="sd">                    (</span>
<span class="sd">                        orderline.c.qty &gt; 100,</span>
<span class="sd">                        literal_column("'greaterthan100'")</span>
<span class="sd">                    ),</span>
<span class="sd">                    (</span>
<span class="sd">                        orderline.c.qty &gt; 10,</span>
<span class="sd">                        literal_column("'greaterthan10'")</span>
<span class="sd">                    )</span>
<span class="sd">                ],</span>
<span class="sd">                else_=literal_column("'lessthan10'")</span>
<span class="sd">            )</span>

<span class="sd">        The above will render the given constants without using bound</span>
<span class="sd">        parameters for the result values (but still for the comparison</span>
<span class="sd">        values), as in::</span>

<span class="sd">            CASE</span>
<span class="sd">                WHEN (orderline.qty &gt; :qty_1) THEN 'greaterthan100'</span>
<span class="sd">                WHEN (orderline.qty &gt; :qty_2) THEN 'greaterthan10'</span>
<span class="sd">                ELSE 'lessthan10'</span>
<span class="sd">            END</span>

<span class="sd">        :param whens: The criteria to be compared against,</span>
<span class="sd">         :paramref:`.case.whens` accepts two different forms, based on</span>
<span class="sd">         whether or not :paramref:`.case.value` is used.</span>

<span class="sd">         In the first form, it accepts a list of 2-tuples; each 2-tuple</span>
<span class="sd">         consists of ``(&lt;sql expression&gt;, &lt;value&gt;)``, where the SQL</span>
<span class="sd">         expression is a boolean expression and "value" is a resulting value,</span>
<span class="sd">         e.g.::</span>

<span class="sd">            case([</span>
<span class="sd">                (users_table.c.name == 'wendy', 'W'),</span>
<span class="sd">                (users_table.c.name == 'jack', 'J')</span>
<span class="sd">            ])</span>

<span class="sd">         In the second form, it accepts a Python dictionary of comparison</span>
<span class="sd">         values mapped to a resulting value; this form requires</span>
<span class="sd">         :paramref:`.case.value` to be present, and values will be compared</span>
<span class="sd">         using the ``==`` operator, e.g.::</span>

<span class="sd">            case(</span>
<span class="sd">                {"wendy": "W", "jack": "J"},</span>
<span class="sd">                value=users_table.c.name</span>
<span class="sd">            )</span>

<span class="sd">        :param value: An optional SQL expression which will be used as a</span>
<span class="sd">          fixed "comparison point" for candidate values within a dictionary</span>
<span class="sd">          passed to :paramref:`.case.whens`.</span>

<span class="sd">        :param else\_: An optional SQL expression which will be the evaluated</span>
<span class="sd">          result of the ``CASE`` construct if all expressions within</span>
<span class="sd">          :paramref:`.case.whens` evaluate to false.  When omitted, most</span>
<span class="sd">          databases will produce a result of NULL if none of the "when"</span>
<span class="sd">          expressions evaluate to true.</span>


<span class="sd">        """</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">whens</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">dictlike_iteritems</span><span class="p">(</span><span class="n">whens</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">whenlist</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">_literal_as_binds</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">self_group</span><span class="p">(),</span> <span class="n">_literal_as_binds</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="ow">in</span> <span class="n">whens</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">whenlist</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">_no_literals</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">self_group</span><span class="p">(),</span> <span class="n">_literal_as_binds</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="ow">in</span> <span class="n">whens</span>
            <span class="p">]</span>

        <span class="k">if</span> <span class="n">whenlist</span><span class="p">:</span>
            <span class="n">type_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">whenlist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">type</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">type_</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">_literal_as_binds</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">whens</span> <span class="o">=</span> <span class="n">whenlist</span>
        <span class="k">if</span> <span class="n">else_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">else_</span> <span class="o">=</span> <span class="n">_literal_as_binds</span><span class="p">(</span><span class="n">else_</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">else_</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_copy_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">_clone</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">whens</span> <span class="o">=</span> <span class="p">[(</span><span class="n">clone</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">),</span> <span class="n">clone</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">whens</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">else_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">else_</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">else_</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">whens</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">x</span>
            <span class="k">yield</span> <span class="n">y</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">else_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">else_</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_from_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span>
            <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">_from_objects</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_children</span><span class="p">()])</span>
        <span class="p">)</span>


<span class="k">def</span> <span class="nf">literal_column</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">"""Produce a :class:`.ColumnClause` object that has the</span>
<span class="sd">    :paramref:`.column.is_literal` flag set to True.</span>

<span class="sd">    :func:`.literal_column` is similar to :func:`.column`, except that</span>
<span class="sd">    it is more often used as a "standalone" column expression that renders</span>
<span class="sd">    exactly as stated; while :func:`.column` stores a string name that</span>
<span class="sd">    will be assumed to be part of a table and may be quoted as such,</span>
<span class="sd">    :func:`.literal_column` can be that, or any other arbitrary column-oriented</span>
<span class="sd">    expression.</span>

<span class="sd">    :param text: the text of the expression; can be any SQL expression.</span>
<span class="sd">      Quoting rules will not be applied. To specify a column-name expression</span>
<span class="sd">      which should be subject to quoting rules, use the :func:`column`</span>
<span class="sd">      function.</span>

<span class="sd">    :param type\_: an optional :class:`~sqlalchemy.types.TypeEngine`</span>
<span class="sd">      object which will</span>
<span class="sd">      provide result-set translation and additional expression semantics for</span>
<span class="sd">      this column. If left as None the type will be NullType.</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :func:`.column`</span>

<span class="sd">        :func:`.text`</span>

<span class="sd">        :ref:`sqlexpression_literal_column`</span>

<span class="sd">    """</span>
    <span class="k">return</span> <span class="n">ColumnClause</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="n">type_</span><span class="p">,</span> <span class="n">is_literal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Cast</span><span class="p">(</span><span class="n">ColumnElement</span><span class="p">):</span>
    <span class="sd">"""Represent a ``CAST`` expression.</span>

<span class="sd">    :class:`.Cast` is produced using the :func:`.cast` factory function,</span>
<span class="sd">    as in::</span>

<span class="sd">        from sqlalchemy import cast, Numeric</span>

<span class="sd">        stmt = select([</span>
<span class="sd">                    cast(product_table.c.unit_price, Numeric(10, 4))</span>
<span class="sd">                ])</span>

<span class="sd">    Details on :class:`.Cast` usage is at :func:`.cast`.</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :ref:`coretutorial_casts`</span>

<span class="sd">        :func:`.cast`</span>

<span class="sd">        :func:`.type_coerce` - an alternative to CAST that coerces the type</span>
<span class="sd">        on the Python side only, which is often sufficient to generate the</span>
<span class="sd">        correct SQL and data coercion.</span>

<span class="sd">    """</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s2">"cast"</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">type_</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Produce a ``CAST`` expression.</span>

<span class="sd">        :func:`.cast` returns an instance of :class:`.Cast`.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            from sqlalchemy import cast, Numeric</span>

<span class="sd">            stmt = select([</span>
<span class="sd">                        cast(product_table.c.unit_price, Numeric(10, 4))</span>
<span class="sd">                    ])</span>

<span class="sd">        The above statement will produce SQL resembling::</span>

<span class="sd">            SELECT CAST(unit_price AS NUMERIC(10, 4)) FROM product</span>

<span class="sd">        The :func:`.cast` function performs two distinct functions when</span>
<span class="sd">        used.  The first is that it renders the ``CAST`` expression within</span>
<span class="sd">        the resulting SQL string.  The second is that it associates the given</span>
<span class="sd">        type (e.g. :class:`.TypeEngine` class or instance) with the column</span>
<span class="sd">        expression on the Python side, which means the expression will take</span>
<span class="sd">        on the expression operator behavior associated with that type,</span>
<span class="sd">        as well as the bound-value handling and result-row-handling behavior</span>
<span class="sd">        of the type.</span>

<span class="sd">        .. versionchanged:: 0.9.0 :func:`.cast` now applies the given type</span>
<span class="sd">           to the expression such that it takes effect on the bound-value,</span>
<span class="sd">           e.g. the Python-to-database direction, in addition to the</span>
<span class="sd">           result handling, e.g. database-to-Python, direction.</span>

<span class="sd">        An alternative to :func:`.cast` is the :func:`.type_coerce` function.</span>
<span class="sd">        This function performs the second task of associating an expression</span>
<span class="sd">        with a specific type, but does not render the ``CAST`` expression</span>
<span class="sd">        in SQL.</span>

<span class="sd">        :param expression: A SQL expression, such as a :class:`.ColumnElement`</span>
<span class="sd">         expression or a Python string which will be coerced into a bound</span>
<span class="sd">         literal value.</span>

<span class="sd">        :param type\_: A :class:`.TypeEngine` class or instance indicating</span>
<span class="sd">         the type to which the ``CAST`` should apply.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`coretutorial_casts`</span>

<span class="sd">            :func:`.type_coerce` - an alternative to CAST that coerces the type</span>
<span class="sd">            on the Python side only, which is often sufficient to generate the</span>
<span class="sd">            correct SQL and data coercion.</span>


<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type_api</span><span class="o">.</span><span class="n">to_instance</span><span class="p">(</span><span class="n">type_</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clause</span> <span class="o">=</span> <span class="n">_literal_as_binds</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typeclause</span> <span class="o">=</span> <span class="n">TypeClause</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_copy_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">_clone</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clause</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clause</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">typeclause</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">typeclause</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clause</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">typeclause</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_from_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clause</span><span class="o">.</span><span class="n">_from_objects</span>


<span class="k">class</span> <span class="nc">TypeCoerce</span><span class="p">(</span><span class="n">ColumnElement</span><span class="p">):</span>
    <span class="sd">"""Represent a Python-side type-coercion wrapper.</span>

<span class="sd">    :class:`.TypeCoerce` supplies the :func:`.expression.type_coerce`</span>
<span class="sd">    function; see that function for usage details.</span>

<span class="sd">    .. versionchanged:: 1.1 The :func:`.type_coerce` function now produces</span>
<span class="sd">       a persistent :class:`.TypeCoerce` wrapper object rather than</span>
<span class="sd">       translating the given object in place.</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :func:`.expression.type_coerce`</span>

<span class="sd">        :func:`.cast`</span>

<span class="sd">    """</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s2">"type_coerce"</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">,</span> <span class="n">type_</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Associate a SQL expression with a particular type, without rendering</span>
<span class="sd">        ``CAST``.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            from sqlalchemy import type_coerce</span>

<span class="sd">            stmt = select([</span>
<span class="sd">                type_coerce(log_table.date_string, StringDateTime())</span>
<span class="sd">            ])</span>

<span class="sd">        The above construct will produce a :class:`.TypeCoerce` object, which</span>
<span class="sd">        renders SQL that labels the expression, but otherwise does not</span>
<span class="sd">        modify its value on the SQL side::</span>

<span class="sd">            SELECT date_string AS anon_1 FROM log</span>

<span class="sd">        When result rows are fetched, the ``StringDateTime`` type</span>
<span class="sd">        will be applied to result rows on behalf of the ``date_string`` column.</span>
<span class="sd">        The rationale for the "anon_1" label is so that the type-coerced</span>
<span class="sd">        column remains separate in the list of result columns vs. other</span>
<span class="sd">        type-coerced or direct values of the target column.  In order to</span>
<span class="sd">        provide a named label for the expression, use</span>
<span class="sd">        :meth:`.ColumnElement.label`::</span>

<span class="sd">            stmt = select([</span>
<span class="sd">                type_coerce(</span>
<span class="sd">                    log_table.date_string, StringDateTime()).label('date')</span>
<span class="sd">            ])</span>


<span class="sd">        A type that features bound-value handling will also have that behavior</span>
<span class="sd">        take effect when literal values or :func:`.bindparam` constructs are</span>
<span class="sd">        passed to :func:`.type_coerce` as targets.</span>
<span class="sd">        For example, if a type implements the</span>
<span class="sd">        :meth:`.TypeEngine.bind_expression`</span>
<span class="sd">        method or :meth:`.TypeEngine.bind_processor` method or equivalent,</span>
<span class="sd">        these functions will take effect at statement compilation/execution</span>
<span class="sd">        time when a literal value is passed, as in::</span>

<span class="sd">            # bound-value handling of MyStringType will be applied to the</span>
<span class="sd">            # literal value "some string"</span>
<span class="sd">            stmt = select([type_coerce("some string", MyStringType)])</span>

<span class="sd">        :func:`.type_coerce` is similar to the :func:`.cast` function,</span>
<span class="sd">        except that it does not render the ``CAST`` expression in the resulting</span>
<span class="sd">        statement.</span>

<span class="sd">        :param expression: A SQL expression, such as a :class:`.ColumnElement`</span>
<span class="sd">         expression or a Python string which will be coerced into a bound</span>
<span class="sd">         literal value.</span>

<span class="sd">        :param type\_: A :class:`.TypeEngine` class or instance indicating</span>
<span class="sd">         the type to which the expression is coerced.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`coretutorial_casts`</span>

<span class="sd">            :func:`.cast`</span>

<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type_api</span><span class="o">.</span><span class="n">to_instance</span><span class="p">(</span><span class="n">type_</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clause</span> <span class="o">=</span> <span class="n">_literal_as_binds</span><span class="p">(</span><span class="n">expression</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_copy_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">_clone</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clause</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clause</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"typed_expression"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clause</span><span class="p">,)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_from_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clause</span><span class="o">.</span><span class="n">_from_objects</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">memoized_property</span>
    <span class="k">def</span> <span class="nf">typed_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clause</span><span class="p">,</span> <span class="n">BindParameter</span><span class="p">):</span>
            <span class="n">bp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clause</span><span class="o">.</span><span class="n">_clone</span><span class="p">()</span>
            <span class="n">bp</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span>
            <span class="k">return</span> <span class="n">bp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">clause</span>


<span class="k">class</span> <span class="nc">Extract</span><span class="p">(</span><span class="n">ColumnElement</span><span class="p">):</span>
    <span class="sd">"""Represent a SQL EXTRACT clause, ``extract(field FROM expr)``."""</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s2">"extract"</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">"""Return a :class:`.Extract` construct.</span>

<span class="sd">        This is typically available as :func:`.extract`</span>
<span class="sd">        as well as ``func.extract`` from the</span>
<span class="sd">        :data:`.func` namespace.</span>

<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type_api</span><span class="o">.</span><span class="n">INTEGERTYPE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">field</span> <span class="o">=</span> <span class="n">field</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="o">=</span> <span class="n">_literal_as_binds</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_copy_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">_clone</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">,)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_from_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">_from_objects</span>


<span class="k">class</span> <span class="nc">_label_reference</span><span class="p">(</span><span class="n">ColumnElement</span><span class="p">):</span>
    <span class="sd">"""Wrap a column expression as it appears in a 'reference' context.</span>

<span class="sd">    This expression is any that includes an _order_by_label_element,</span>
<span class="sd">    which is a Label, or a DESC / ASC construct wrapping a Label.</span>

<span class="sd">    The production of _label_reference() should occur when an expression</span>
<span class="sd">    is added to this context; this includes the ORDER BY or GROUP BY of a</span>
<span class="sd">    SELECT statement, as well as a few other places, such as the ORDER BY</span>
<span class="sd">    within an OVER clause.</span>

<span class="sd">    """</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s2">"label_reference"</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="n">element</span>

    <span class="k">def</span> <span class="nf">_copy_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">_clone</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_from_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">()</span>


<span class="k">class</span> <span class="nc">_textual_label_reference</span><span class="p">(</span><span class="n">ColumnElement</span><span class="p">):</span>
    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s2">"textual_label_reference"</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="n">element</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">memoized_property</span>
    <span class="k">def</span> <span class="nf">_text_clause</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TextClause</span><span class="o">.</span><span class="n">_create_text</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">UnaryExpression</span><span class="p">(</span><span class="n">ColumnElement</span><span class="p">):</span>
    <span class="sd">"""Define a 'unary' expression.</span>

<span class="sd">    A unary expression has a single column expression</span>
<span class="sd">    and an operator.  The operator can be placed on the left</span>
<span class="sd">    (where it is called the 'operator') or right (where it is called the</span>
<span class="sd">    'modifier') of the column expression.</span>

<span class="sd">    :class:`.UnaryExpression` is the basis for several unary operators</span>
<span class="sd">    including those used by :func:`.desc`, :func:`.asc`, :func:`.distinct`,</span>
<span class="sd">    :func:`.nullsfirst` and :func:`.nullslast`.</span>

<span class="sd">    """</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s2">"unary"</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">element</span><span class="p">,</span>
        <span class="n">operator</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">modifier</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">type_</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">negate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">wraps_column_expression</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">=</span> <span class="n">operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modifier</span> <span class="o">=</span> <span class="n">modifier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">self_group</span><span class="p">(</span>
            <span class="n">against</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">modifier</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type_api</span><span class="o">.</span><span class="n">to_instance</span><span class="p">(</span><span class="n">type_</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">negate</span> <span class="o">=</span> <span class="n">negate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wraps_column_expression</span> <span class="o">=</span> <span class="n">wraps_column_expression</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_create_nullsfirst</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="sd">"""Produce the ``NULLS FIRST`` modifier for an ``ORDER BY`` expression.</span>

<span class="sd">        :func:`.nullsfirst` is intended to modify the expression produced</span>
<span class="sd">        by :func:`.asc` or :func:`.desc`, and indicates how NULL values</span>
<span class="sd">        should be handled when they are encountered during ordering::</span>


<span class="sd">            from sqlalchemy import desc, nullsfirst</span>

<span class="sd">            stmt = select([users_table]).\</span>
<span class="sd">                        order_by(nullsfirst(desc(users_table.c.name)))</span>

<span class="sd">        The SQL expression from the above would resemble::</span>

<span class="sd">            SELECT id, name FROM user ORDER BY name DESC NULLS FIRST</span>

<span class="sd">        Like :func:`.asc` and :func:`.desc`, :func:`.nullsfirst` is typically</span>
<span class="sd">        invoked from the column expression itself using</span>
<span class="sd">        :meth:`.ColumnElement.nullsfirst`, rather than as its standalone</span>
<span class="sd">        function version, as in::</span>

<span class="sd">            stmt = (select([users_table]).</span>
<span class="sd">                    order_by(users_table.c.name.desc().nullsfirst())</span>
<span class="sd">                    )</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :func:`.asc`</span>

<span class="sd">            :func:`.desc`</span>

<span class="sd">            :func:`.nullslast`</span>

<span class="sd">            :meth:`.Select.order_by`</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">UnaryExpression</span><span class="p">(</span>
            <span class="n">_literal_as_label_reference</span><span class="p">(</span><span class="n">column</span><span class="p">),</span>
            <span class="n">modifier</span><span class="o">=</span><span class="n">operators</span><span class="o">.</span><span class="n">nullsfirst_op</span><span class="p">,</span>
            <span class="n">wraps_column_expression</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_create_nullslast</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="sd">"""Produce the ``NULLS LAST`` modifier for an ``ORDER BY`` expression.</span>

<span class="sd">        :func:`.nullslast` is intended to modify the expression produced</span>
<span class="sd">        by :func:`.asc` or :func:`.desc`, and indicates how NULL values</span>
<span class="sd">        should be handled when they are encountered during ordering::</span>


<span class="sd">            from sqlalchemy import desc, nullslast</span>

<span class="sd">            stmt = select([users_table]).\</span>
<span class="sd">                        order_by(nullslast(desc(users_table.c.name)))</span>

<span class="sd">        The SQL expression from the above would resemble::</span>

<span class="sd">            SELECT id, name FROM user ORDER BY name DESC NULLS LAST</span>

<span class="sd">        Like :func:`.asc` and :func:`.desc`, :func:`.nullslast` is typically</span>
<span class="sd">        invoked from the column expression itself using</span>
<span class="sd">        :meth:`.ColumnElement.nullslast`, rather than as its standalone</span>
<span class="sd">        function version, as in::</span>

<span class="sd">            stmt = select([users_table]).\</span>
<span class="sd">                        order_by(users_table.c.name.desc().nullslast())</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :func:`.asc`</span>

<span class="sd">            :func:`.desc`</span>

<span class="sd">            :func:`.nullsfirst`</span>

<span class="sd">            :meth:`.Select.order_by`</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">UnaryExpression</span><span class="p">(</span>
            <span class="n">_literal_as_label_reference</span><span class="p">(</span><span class="n">column</span><span class="p">),</span>
            <span class="n">modifier</span><span class="o">=</span><span class="n">operators</span><span class="o">.</span><span class="n">nullslast_op</span><span class="p">,</span>
            <span class="n">wraps_column_expression</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_create_desc</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="sd">"""Produce a descending ``ORDER BY`` clause element.</span>

<span class="sd">        e.g.::</span>

<span class="sd">            from sqlalchemy import desc</span>

<span class="sd">            stmt = select([users_table]).order_by(desc(users_table.c.name))</span>

<span class="sd">        will produce SQL as::</span>

<span class="sd">            SELECT id, name FROM user ORDER BY name DESC</span>

<span class="sd">        The :func:`.desc` function is a standalone version of the</span>
<span class="sd">        :meth:`.ColumnElement.desc` method available on all SQL expressions,</span>
<span class="sd">        e.g.::</span>


<span class="sd">            stmt = select([users_table]).order_by(users_table.c.name.desc())</span>

<span class="sd">        :param column: A :class:`.ColumnElement` (e.g. scalar SQL expression)</span>
<span class="sd">         with which to apply the :func:`.desc` operation.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :func:`.asc`</span>

<span class="sd">            :func:`.nullsfirst`</span>

<span class="sd">            :func:`.nullslast`</span>

<span class="sd">            :meth:`.Select.order_by`</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">UnaryExpression</span><span class="p">(</span>
            <span class="n">_literal_as_label_reference</span><span class="p">(</span><span class="n">column</span><span class="p">),</span>
            <span class="n">modifier</span><span class="o">=</span><span class="n">operators</span><span class="o">.</span><span class="n">desc_op</span><span class="p">,</span>
            <span class="n">wraps_column_expression</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_create_asc</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="sd">"""Produce an ascending ``ORDER BY`` clause element.</span>

<span class="sd">        e.g.::</span>

<span class="sd">            from sqlalchemy import asc</span>
<span class="sd">            stmt = select([users_table]).order_by(asc(users_table.c.name))</span>

<span class="sd">        will produce SQL as::</span>

<span class="sd">            SELECT id, name FROM user ORDER BY name ASC</span>

<span class="sd">        The :func:`.asc` function is a standalone version of the</span>
<span class="sd">        :meth:`.ColumnElement.asc` method available on all SQL expressions,</span>
<span class="sd">        e.g.::</span>


<span class="sd">            stmt = select([users_table]).order_by(users_table.c.name.asc())</span>

<span class="sd">        :param column: A :class:`.ColumnElement` (e.g. scalar SQL expression)</span>
<span class="sd">         with which to apply the :func:`.asc` operation.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :func:`.desc`</span>

<span class="sd">            :func:`.nullsfirst`</span>

<span class="sd">            :func:`.nullslast`</span>

<span class="sd">            :meth:`.Select.order_by`</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">UnaryExpression</span><span class="p">(</span>
            <span class="n">_literal_as_label_reference</span><span class="p">(</span><span class="n">column</span><span class="p">),</span>
            <span class="n">modifier</span><span class="o">=</span><span class="n">operators</span><span class="o">.</span><span class="n">asc_op</span><span class="p">,</span>
            <span class="n">wraps_column_expression</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_create_distinct</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="sd">"""Produce an column-expression-level unary ``DISTINCT`` clause.</span>

<span class="sd">        This applies the ``DISTINCT`` keyword to an individual column</span>
<span class="sd">        expression, and is typically contained within an aggregate function,</span>
<span class="sd">        as in::</span>

<span class="sd">            from sqlalchemy import distinct, func</span>
<span class="sd">            stmt = select([func.count(distinct(users_table.c.name))])</span>

<span class="sd">        The above would produce an expression resembling::</span>

<span class="sd">            SELECT COUNT(DISTINCT name) FROM user</span>

<span class="sd">        The :func:`.distinct` function is also available as a column-level</span>
<span class="sd">        method, e.g. :meth:`.ColumnElement.distinct`, as in::</span>

<span class="sd">            stmt = select([func.count(users_table.c.name.distinct())])</span>

<span class="sd">        The :func:`.distinct` operator is different from the</span>
<span class="sd">        :meth:`.Select.distinct` method of :class:`.Select`,</span>
<span class="sd">        which produces a ``SELECT`` statement</span>
<span class="sd">        with ``DISTINCT`` applied to the result set as a whole,</span>
<span class="sd">        e.g. a ``SELECT DISTINCT`` expression.  See that method for further</span>
<span class="sd">        information.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.ColumnElement.distinct`</span>

<span class="sd">            :meth:`.Select.distinct`</span>

<span class="sd">            :data:`.func`</span>

<span class="sd">        """</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">_literal_as_binds</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">UnaryExpression</span><span class="p">(</span>
            <span class="n">expr</span><span class="p">,</span>
            <span class="n">operator</span><span class="o">=</span><span class="n">operators</span><span class="o">.</span><span class="n">distinct_op</span><span class="p">,</span>
            <span class="n">type_</span><span class="o">=</span><span class="n">expr</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
            <span class="n">wraps_column_expression</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_order_by_label_element</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">modifier</span> <span class="ow">in</span> <span class="p">(</span><span class="n">operators</span><span class="o">.</span><span class="n">desc_op</span><span class="p">,</span> <span class="n">operators</span><span class="o">.</span><span class="n">asc_op</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">_order_by_label_element</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_from_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">_from_objects</span>

    <span class="k">def</span> <span class="nf">_copy_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">_clone</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,)</span>

    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">"""Compare this :class:`UnaryExpression` against the given</span>
<span class="sd">        :class:`.ClauseElement`."""</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">UnaryExpression</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">operator</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">modifier</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">modifier</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">element</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_negate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">negate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">UnaryExpression</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,</span>
                <span class="n">operator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">negate</span><span class="p">,</span>
                <span class="n">negate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span>
                <span class="n">modifier</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">modifier</span><span class="p">,</span>
                <span class="n">type_</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
                <span class="n">wraps_column_expression</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">wraps_column_expression</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">_type_affinity</span> <span class="ow">is</span> <span class="n">type_api</span><span class="o">.</span><span class="n">BOOLEANTYPE</span><span class="o">.</span><span class="n">_type_affinity</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">UnaryExpression</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">self_group</span><span class="p">(</span><span class="n">against</span><span class="o">=</span><span class="n">operators</span><span class="o">.</span><span class="n">inv</span><span class="p">),</span>
                <span class="n">operator</span><span class="o">=</span><span class="n">operators</span><span class="o">.</span><span class="n">inv</span><span class="p">,</span>
                <span class="n">type_</span><span class="o">=</span><span class="n">type_api</span><span class="o">.</span><span class="n">BOOLEANTYPE</span><span class="p">,</span>
                <span class="n">wraps_column_expression</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">wraps_column_expression</span><span class="p">,</span>
                <span class="n">negate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ClauseElement</span><span class="o">.</span><span class="n">_negate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">self_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">against</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="ow">and</span> <span class="n">operators</span><span class="o">.</span><span class="n">is_precedent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span> <span class="n">against</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Grouping</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>


<span class="k">class</span> <span class="nc">CollectionAggregate</span><span class="p">(</span><span class="n">UnaryExpression</span><span class="p">):</span>
    <span class="sd">"""Forms the basis for right-hand collection operator modifiers</span>
<span class="sd">    ANY and ALL.</span>

<span class="sd">    The ANY and ALL keywords are available in different ways on different</span>
<span class="sd">    backends.  On PostgreSQL, they only work for an ARRAY type.  On</span>
<span class="sd">    MySQL, they only work for subqueries.</span>

<span class="sd">    """</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_create_any</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="sd">"""Produce an ANY expression.</span>

<span class="sd">        This may apply to an array type for some dialects (e.g. postgresql),</span>
<span class="sd">        or to a subquery for others (e.g. mysql).  e.g.::</span>

<span class="sd">            # postgresql '5 = ANY (somearray)'</span>
<span class="sd">            expr = 5 == any_(mytable.c.somearray)</span>

<span class="sd">            # mysql '5 = ANY (SELECT value FROM table)'</span>
<span class="sd">            expr = 5 == any_(select([table.c.value]))</span>

<span class="sd">        .. versionadded:: 1.1</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :func:`.expression.all_`</span>

<span class="sd">        """</span>

        <span class="n">expr</span> <span class="o">=</span> <span class="n">_literal_as_binds</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_selectable</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s2">"as_scalar"</span><span class="p">):</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">as_scalar</span><span class="p">()</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">self_group</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">CollectionAggregate</span><span class="p">(</span>
            <span class="n">expr</span><span class="p">,</span>
            <span class="n">operator</span><span class="o">=</span><span class="n">operators</span><span class="o">.</span><span class="n">any_op</span><span class="p">,</span>
            <span class="n">type_</span><span class="o">=</span><span class="n">type_api</span><span class="o">.</span><span class="n">NULLTYPE</span><span class="p">,</span>
            <span class="n">wraps_column_expression</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_create_all</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
        <span class="sd">"""Produce an ALL expression.</span>

<span class="sd">        This may apply to an array type for some dialects (e.g. postgresql),</span>
<span class="sd">        or to a subquery for others (e.g. mysql).  e.g.::</span>

<span class="sd">            # postgresql '5 = ALL (somearray)'</span>
<span class="sd">            expr = 5 == all_(mytable.c.somearray)</span>

<span class="sd">            # mysql '5 = ALL (SELECT value FROM table)'</span>
<span class="sd">            expr = 5 == all_(select([table.c.value]))</span>

<span class="sd">        .. versionadded:: 1.1</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :func:`.expression.any_`</span>

<span class="sd">        """</span>

        <span class="n">expr</span> <span class="o">=</span> <span class="n">_literal_as_binds</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">is_selectable</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s2">"as_scalar"</span><span class="p">):</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">as_scalar</span><span class="p">()</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">self_group</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">CollectionAggregate</span><span class="p">(</span>
            <span class="n">expr</span><span class="p">,</span>
            <span class="n">operator</span><span class="o">=</span><span class="n">operators</span><span class="o">.</span><span class="n">all_op</span><span class="p">,</span>
            <span class="n">type_</span><span class="o">=</span><span class="n">type_api</span><span class="o">.</span><span class="n">NULLTYPE</span><span class="p">,</span>
            <span class="n">wraps_column_expression</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># operate and reverse_operate are hardwired to</span>
    <span class="c1"># dispatch onto the type comparator directly, so that we can</span>
    <span class="c1"># ensure "reversed" behavior.</span>
    <span class="k">def</span> <span class="nf">operate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">operators</span><span class="o">.</span><span class="n">is_comparison</span><span class="p">(</span><span class="n">op</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
                <span class="s2">"Only comparison operators may be used with ANY/ALL"</span>
            <span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">"reverse"</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">comparator</span><span class="o">.</span><span class="n">operate</span><span class="p">(</span><span class="n">operators</span><span class="o">.</span><span class="n">mirror</span><span class="p">(</span><span class="n">op</span><span class="p">),</span> <span class="o">*</span><span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reverse_operate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># comparison operators should never call reverse_operate</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">operators</span><span class="o">.</span><span class="n">is_comparison</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
        <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
            <span class="s2">"Only comparison operators may be used with ANY/ALL"</span>
        <span class="p">)</span>


<span class="k">class</span> <span class="nc">AsBoolean</span><span class="p">(</span><span class="n">UnaryExpression</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">negate</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="n">element</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type_api</span><span class="o">.</span><span class="n">BOOLEANTYPE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">=</span> <span class="n">operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">negate</span> <span class="o">=</span> <span class="n">negate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modifier</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wraps_column_expression</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_implicitly_boolean</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">_is_implicitly_boolean</span>

    <span class="k">def</span> <span class="nf">self_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">against</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_negate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,</span> <span class="p">(</span><span class="n">True_</span><span class="p">,</span> <span class="n">False_</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">_negate</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">AsBoolean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">negate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">BinaryExpression</span><span class="p">(</span><span class="n">ColumnElement</span><span class="p">):</span>
    <span class="sd">"""Represent an expression that is ``LEFT &lt;operator&gt; RIGHT``.</span>

<span class="sd">    A :class:`.BinaryExpression` is generated automatically</span>
<span class="sd">    whenever two column expressions are used in a Python binary expression::</span>

<span class="sd">        &gt;&gt;&gt; from sqlalchemy.sql import column</span>
<span class="sd">        &gt;&gt;&gt; column('a') + column('b')</span>
<span class="sd">        &lt;sqlalchemy.sql.expression.BinaryExpression object at 0x101029dd0&gt;</span>
<span class="sd">        &gt;&gt;&gt; print(column('a') + column('b'))</span>
<span class="sd">        a + b</span>

<span class="sd">    """</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s2">"binary"</span>

    <span class="n">_is_implicitly_boolean</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="sd">"""Indicates that any database will know this is a boolean expression</span>
<span class="sd">    even if the database does not have an explicit boolean datatype.</span>

<span class="sd">    """</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">negate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">modifiers</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="c1"># allow compatibility with libraries that</span>
        <span class="c1"># refer to BinaryExpression directly and pass strings</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
            <span class="n">operator</span> <span class="o">=</span> <span class="n">operators</span><span class="o">.</span><span class="n">custom_op</span><span class="p">(</span><span class="n">operator</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orig</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">self_group</span><span class="p">(</span><span class="n">against</span><span class="o">=</span><span class="n">operator</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">self_group</span><span class="p">(</span><span class="n">against</span><span class="o">=</span><span class="n">operator</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">=</span> <span class="n">operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type_api</span><span class="o">.</span><span class="n">to_instance</span><span class="p">(</span><span class="n">type_</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">negate</span> <span class="o">=</span> <span class="n">negate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_implicitly_boolean</span> <span class="o">=</span> <span class="n">operators</span><span class="o">.</span><span class="n">is_boolean</span><span class="p">(</span><span class="n">operator</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">modifiers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">modifiers</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">modifiers</span> <span class="o">=</span> <span class="n">modifiers</span>

    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="ow">in</span> <span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">eq</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">ne</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"Boolean value of this clause is not defined"</span><span class="p">)</span>

    <span class="n">__nonzero__</span> <span class="o">=</span> <span class="fm">__bool__</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_comparison</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">operators</span><span class="o">.</span><span class="n">is_comparison</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_from_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">_from_objects</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">_from_objects</span>

    <span class="k">def</span> <span class="nf">_copy_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">_clone</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span>

    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">"""Compare this :class:`BinaryExpression` against the</span>
<span class="sd">        given :class:`BinaryExpression`."""</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BinaryExpression</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">operator</span>
            <span class="ow">and</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span>
                    <span class="n">operators</span><span class="o">.</span><span class="n">is_commutative</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">self_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">against</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">operators</span><span class="o">.</span><span class="n">is_precedent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span> <span class="n">against</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Grouping</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_negate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">negate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BinaryExpression</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">negate</span><span class="p">,</span>
                <span class="n">negate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">,</span>
                <span class="n">type_</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
                <span class="n">modifiers</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">modifiers</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">BinaryExpression</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_negate</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">Slice</span><span class="p">(</span><span class="n">ColumnElement</span><span class="p">):</span>
    <span class="sd">"""Represent SQL for a Python array-slice object.</span>

<span class="sd">    This is not a specific SQL construct at this level, but</span>
<span class="sd">    may be interpreted by specific dialects, e.g. PostgreSQL.</span>

<span class="sd">    """</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s2">"slice"</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stop</span> <span class="o">=</span> <span class="n">stop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">step</span> <span class="o">=</span> <span class="n">step</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type_api</span><span class="o">.</span><span class="n">NULLTYPE</span>

    <span class="k">def</span> <span class="nf">self_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">against</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">against</span> <span class="ow">is</span> <span class="n">operator</span><span class="o">.</span><span class="n">getitem</span>
        <span class="k">return</span> <span class="bp">self</span>


<span class="k">class</span> <span class="nc">IndexExpression</span><span class="p">(</span><span class="n">BinaryExpression</span><span class="p">):</span>
    <span class="sd">"""Represent the class of expressions that are like an "index" operation.</span>
<span class="sd">    """</span>

    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">Grouping</span><span class="p">(</span><span class="n">ColumnElement</span><span class="p">):</span>
    <span class="sd">"""Represent a grouping within a column expression"""</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s2">"grouping"</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="n">element</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s2">"type"</span><span class="p">,</span> <span class="n">type_api</span><span class="o">.</span><span class="n">NULLTYPE</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">self_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">against</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">memoized_property</span>
    <span class="k">def</span> <span class="nf">_is_implicitly_boolean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">_is_implicitly_boolean</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_key_label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,</span> <span class="s2">"_label"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">anon_label</span>

    <span class="k">def</span> <span class="nf">_copy_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">_clone</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_from_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">_from_objects</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">"element"</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,</span> <span class="s2">"type"</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">"element"</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">"type"</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Grouping</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span>
            <span class="n">other</span><span class="o">.</span><span class="n">element</span>
        <span class="p">)</span>


<span class="n">RANGE_UNBOUNDED</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">symbol</span><span class="p">(</span><span class="s2">"RANGE_UNBOUNDED"</span><span class="p">)</span>
<span class="n">RANGE_CURRENT</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">symbol</span><span class="p">(</span><span class="s2">"RANGE_CURRENT"</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Over</span><span class="p">(</span><span class="n">ColumnElement</span><span class="p">):</span>
    <span class="sd">"""Represent an OVER clause.</span>

<span class="sd">    This is a special operator against a so-called</span>
<span class="sd">    "window" function, as well as any aggregate function,</span>
<span class="sd">    which produces results relative to the result set</span>
<span class="sd">    itself.  It's supported only by certain database</span>
<span class="sd">    backends.</span>

<span class="sd">    """</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s2">"over"</span>

    <span class="n">order_by</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">partition_by</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">element</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">"""The underlying expression object to which this :class:`.Over`</span>
<span class="sd">    object refers towards."""</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="n">partition_by</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order_by</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">range_</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Produce an :class:`.Over` object against a function.</span>

<span class="sd">        Used against aggregate or so-called "window" functions,</span>
<span class="sd">        for database backends that support window functions.</span>

<span class="sd">        :func:`~.expression.over` is usually called using</span>
<span class="sd">        the :meth:`.FunctionElement.over` method, e.g.::</span>

<span class="sd">            func.row_number().over(order_by=mytable.c.some_column)</span>

<span class="sd">        Would produce::</span>

<span class="sd">            ROW_NUMBER() OVER(ORDER BY some_column)</span>

<span class="sd">        Ranges are also possible using the :paramref:`.expression.over.range_`</span>
<span class="sd">        and :paramref:`.expression.over.rows` parameters.  These</span>
<span class="sd">        mutually-exclusive parameters each accept a 2-tuple, which contains</span>
<span class="sd">        a combination of integers and None::</span>

<span class="sd">            func.row_number().over(</span>
<span class="sd">                order_by=my_table.c.some_column, range_=(None, 0))</span>

<span class="sd">        The above would produce::</span>

<span class="sd">            ROW_NUMBER() OVER(ORDER BY some_column</span>
<span class="sd">            RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)</span>

<span class="sd">        A value of None indicates "unbounded", a</span>
<span class="sd">        value of zero indicates "current row", and negative / positive</span>
<span class="sd">        integers indicate "preceding" and "following":</span>

<span class="sd">        * RANGE BETWEEN 5 PRECEDING AND 10 FOLLOWING::</span>

<span class="sd">            func.row_number().over(order_by='x', range_=(-5, 10))</span>

<span class="sd">        * ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW::</span>

<span class="sd">            func.row_number().over(order_by='x', rows=(None, 0))</span>

<span class="sd">        * RANGE BETWEEN 2 PRECEDING AND UNBOUNDED FOLLOWING::</span>

<span class="sd">            func.row_number().over(order_by='x', range_=(-2, None))</span>

<span class="sd">        * RANGE BETWEEN 1 FOLLOWING AND 3 FOLLOWING::</span>

<span class="sd">            func.row_number().over(order_by='x', range_=(1, 3))</span>

<span class="sd">        .. versionadded:: 1.1 support for RANGE / ROWS within a window</span>


<span class="sd">        :param element: a :class:`.FunctionElement`, :class:`.WithinGroup`,</span>
<span class="sd">         or other compatible construct.</span>
<span class="sd">        :param partition_by: a column element or string, or a list</span>
<span class="sd">         of such, that will be used as the PARTITION BY clause</span>
<span class="sd">         of the OVER construct.</span>
<span class="sd">        :param order_by: a column element or string, or a list</span>
<span class="sd">         of such, that will be used as the ORDER BY clause</span>
<span class="sd">         of the OVER construct.</span>
<span class="sd">        :param range\_: optional range clause for the window.  This is a</span>
<span class="sd">         tuple value which can contain integer values or None, and will</span>
<span class="sd">         render a RANGE BETWEEN PRECEDING / FOLLOWING clause</span>

<span class="sd">         .. versionadded:: 1.1</span>

<span class="sd">        :param rows: optional rows clause for the window.  This is a tuple</span>
<span class="sd">         value which can contain integer values or None, and will render</span>
<span class="sd">         a ROWS BETWEEN PRECEDING / FOLLOWING clause.</span>

<span class="sd">         .. versionadded:: 1.1</span>

<span class="sd">        This function is also available from the :data:`~.expression.func`</span>
<span class="sd">        construct itself via the :meth:`.FunctionElement.over` method.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :data:`.expression.func`</span>

<span class="sd">            :func:`.expression.within_group`</span>

<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="n">element</span>
        <span class="k">if</span> <span class="n">order_by</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order_by</span> <span class="o">=</span> <span class="n">ClauseList</span><span class="p">(</span>
                <span class="o">*</span><span class="n">util</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">order_by</span><span class="p">),</span>
                <span class="n">_literal_as_text</span><span class="o">=</span><span class="n">_literal_as_label_reference</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">partition_by</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">partition_by</span> <span class="o">=</span> <span class="n">ClauseList</span><span class="p">(</span>
                <span class="o">*</span><span class="n">util</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">partition_by</span><span class="p">),</span>
                <span class="n">_literal_as_text</span><span class="o">=</span><span class="n">_literal_as_label_reference</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">range_</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">range_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpret_range</span><span class="p">(</span><span class="n">range_</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rows</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
                    <span class="s2">"'range_' and 'rows' are mutually exclusive"</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">rows</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpret_range</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">range_</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_interpret_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">range_</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">range_</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">range_</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span><span class="s2">"2-tuple expected for range/rows"</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">range_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lower</span> <span class="o">=</span> <span class="n">RANGE_UNBOUNDED</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">lower</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">range_</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="n">util</span><span class="o">.</span><span class="n">raise_</span><span class="p">(</span>
                    <span class="n">exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
                        <span class="s2">"Integer or None expected for range value"</span>
                    <span class="p">),</span>
                    <span class="n">replace_context</span><span class="o">=</span><span class="n">err</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">lower</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">lower</span> <span class="o">=</span> <span class="n">RANGE_CURRENT</span>

        <span class="k">if</span> <span class="n">range_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">upper</span> <span class="o">=</span> <span class="n">RANGE_UNBOUNDED</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">upper</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">range_</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="n">util</span><span class="o">.</span><span class="n">raise_</span><span class="p">(</span>
                    <span class="n">exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
                        <span class="s2">"Integer or None expected for range value"</span>
                    <span class="p">),</span>
                    <span class="n">replace_context</span><span class="o">=</span><span class="n">err</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">upper</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">upper</span> <span class="o">=</span> <span class="n">RANGE_CURRENT</span>

        <span class="k">return</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span>

    <span class="nd">@property</span>
    <span class="nd">@util</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span>
        <span class="s2">"1.1"</span><span class="p">,</span>
        <span class="s2">"the :attr:`.Over.func` member of the :class:`.Over` "</span>
        <span class="s2">"class is deprecated and will be removed in a future release.  "</span>
        <span class="s2">"Please refer to the :attr:`.Over.element` attribute."</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""the element referred to by this :class:`.Over`</span>
<span class="sd">        clause.</span>


<span class="sd">        """</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">memoized_property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">type</span>

    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">c</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition_by</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order_by</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">]</span>

    <span class="k">def</span> <span class="nf">_copy_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">_clone</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition_by</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">partition_by</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">partition_by</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">order_by</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order_by</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order_by</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_from_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span>
            <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
                <span class="o">*</span><span class="p">[</span>
                    <span class="n">c</span><span class="o">.</span><span class="n">_from_objects</span>
                    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">partition_by</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order_by</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="p">]</span>
            <span class="p">)</span>
        <span class="p">)</span>


<span class="k">class</span> <span class="nc">WithinGroup</span><span class="p">(</span><span class="n">ColumnElement</span><span class="p">):</span>
    <span class="sd">"""Represent a WITHIN GROUP (ORDER BY) clause.</span>

<span class="sd">    This is a special operator against so-called</span>
<span class="sd">    "ordered set aggregate" and "hypothetical</span>
<span class="sd">    set aggregate" functions, including ``percentile_cont()``,</span>
<span class="sd">    ``rank()``, ``dense_rank()``, etc.</span>

<span class="sd">    It's supported only by certain database backends, such as PostgreSQL,</span>
<span class="sd">    Oracle and MS SQL Server.</span>

<span class="sd">    The :class:`.WithinGroup` construct extracts its type from the</span>
<span class="sd">    method :meth:`.FunctionElement.within_group_type`.  If this returns</span>
<span class="sd">    ``None``, the function's ``.type`` is used.</span>

<span class="sd">    """</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s2">"withingroup"</span>

    <span class="n">order_by</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="o">*</span><span class="n">order_by</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""Produce a :class:`.WithinGroup` object against a function.</span>

<span class="sd">        Used against so-called "ordered set aggregate" and "hypothetical</span>
<span class="sd">        set aggregate" functions, including :class:`.percentile_cont`,</span>
<span class="sd">        :class:`.rank`, :class:`.dense_rank`, etc.</span>

<span class="sd">        :func:`~.expression.within_group` is usually called using</span>
<span class="sd">        the :meth:`.FunctionElement.within_group` method, e.g.::</span>

<span class="sd">            from sqlalchemy import within_group</span>
<span class="sd">            stmt = select([</span>
<span class="sd">                department.c.id,</span>
<span class="sd">                func.percentile_cont(0.5).within_group(</span>
<span class="sd">                    department.c.salary.desc()</span>
<span class="sd">                )</span>
<span class="sd">            ])</span>

<span class="sd">        The above statement would produce SQL similar to</span>
<span class="sd">        ``SELECT department.id, percentile_cont(0.5)</span>
<span class="sd">        WITHIN GROUP (ORDER BY department.salary DESC)``.</span>

<span class="sd">        :param element: a :class:`.FunctionElement` construct, typically</span>
<span class="sd">         generated by :data:`~.expression.func`.</span>
<span class="sd">        :param \*order_by: one or more column elements that will be used</span>
<span class="sd">         as the ORDER BY clause of the WITHIN GROUP construct.</span>

<span class="sd">        .. versionadded:: 1.1</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :data:`.expression.func`</span>

<span class="sd">            :func:`.expression.over`</span>

<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="n">element</span>
        <span class="k">if</span> <span class="n">order_by</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order_by</span> <span class="o">=</span> <span class="n">ClauseList</span><span class="p">(</span>
                <span class="o">*</span><span class="n">util</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">order_by</span><span class="p">),</span>
                <span class="n">_literal_as_text</span><span class="o">=</span><span class="n">_literal_as_label_reference</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">over</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">partition_by</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order_by</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">range_</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""Produce an OVER clause against this :class:`.WithinGroup`</span>
<span class="sd">        construct.</span>

<span class="sd">        This function has the same signature as that of</span>
<span class="sd">        :meth:`.FunctionElement.over`.</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">Over</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">partition_by</span><span class="o">=</span><span class="n">partition_by</span><span class="p">,</span>
            <span class="n">order_by</span><span class="o">=</span><span class="n">order_by</span><span class="p">,</span>
            <span class="n">range_</span><span class="o">=</span><span class="n">range_</span><span class="p">,</span>
            <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">memoized_property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">wgt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">within_group_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">wgt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">wgt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">type</span>

    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order_by</span><span class="p">)</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_copy_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">_clone</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">order_by</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order_by</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order_by</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_from_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span>
            <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
                <span class="o">*</span><span class="p">[</span>
                    <span class="n">c</span><span class="o">.</span><span class="n">_from_objects</span>
                    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order_by</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="p">]</span>
            <span class="p">)</span>
        <span class="p">)</span>


<span class="k">class</span> <span class="nc">FunctionFilter</span><span class="p">(</span><span class="n">ColumnElement</span><span class="p">):</span>
    <span class="sd">"""Represent a function FILTER clause.</span>

<span class="sd">    This is a special operator against aggregate and window functions,</span>
<span class="sd">    which controls which rows are passed to it.</span>
<span class="sd">    It's supported only by certain database backends.</span>

<span class="sd">    Invocation of :class:`.FunctionFilter` is via</span>
<span class="sd">    :meth:`.FunctionElement.filter`::</span>

<span class="sd">        func.count(1).filter(True)</span>

<span class="sd">    .. versionadded:: 1.0.0</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :meth:`.FunctionElement.filter`</span>

<span class="sd">    """</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s2">"funcfilter"</span>

    <span class="n">criterion</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">criterion</span><span class="p">):</span>
        <span class="sd">"""Produce a :class:`.FunctionFilter` object against a function.</span>

<span class="sd">        Used against aggregate and window functions,</span>
<span class="sd">        for database backends that support the "FILTER" clause.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            from sqlalchemy import funcfilter</span>
<span class="sd">            funcfilter(func.count(1), MyClass.name == 'some name')</span>

<span class="sd">        Would produce "COUNT(1) FILTER (WHERE myclass.name = 'some name')".</span>

<span class="sd">        This function is also available from the :data:`~.expression.func`</span>
<span class="sd">        construct itself via the :meth:`.FunctionElement.filter` method.</span>

<span class="sd">        .. versionadded:: 1.0.0</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.FunctionElement.filter`</span>


<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="o">*</span><span class="n">criterion</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">criterion</span><span class="p">):</span>
        <span class="sd">"""Produce an additional FILTER against the function.</span>

<span class="sd">        This method adds additional criteria to the initial criteria</span>
<span class="sd">        set up by :meth:`.FunctionElement.filter`.</span>

<span class="sd">        Multiple criteria are joined together at SQL render time</span>
<span class="sd">        via ``AND``.</span>


<span class="sd">        """</span>

        <span class="k">for</span> <span class="n">criterion</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">criterion</span><span class="p">):</span>
            <span class="n">criterion</span> <span class="o">=</span> <span class="n">_expression_literal_as_text</span><span class="p">(</span><span class="n">criterion</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span> <span class="o">&amp;</span> <span class="n">criterion</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span> <span class="o">=</span> <span class="n">criterion</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">over</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">partition_by</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order_by</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">range_</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rows</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""Produce an OVER clause against this filtered function.</span>

<span class="sd">        Used against aggregate or so-called "window" functions,</span>
<span class="sd">        for database backends that support window functions.</span>

<span class="sd">        The expression::</span>

<span class="sd">            func.rank().filter(MyClass.y &gt; 5).over(order_by='x')</span>

<span class="sd">        is shorthand for::</span>

<span class="sd">            from sqlalchemy import over, funcfilter</span>
<span class="sd">            over(funcfilter(func.rank(), MyClass.y &gt; 5), order_by='x')</span>

<span class="sd">        See :func:`~.expression.over` for a full description.</span>

<span class="sd">        """</span>
        <span class="k">return</span> <span class="n">Over</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">partition_by</span><span class="o">=</span><span class="n">partition_by</span><span class="p">,</span>
            <span class="n">order_by</span><span class="o">=</span><span class="n">order_by</span><span class="p">,</span>
            <span class="n">range_</span><span class="o">=</span><span class="n">range_</span><span class="p">,</span>
            <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">self_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">against</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">operators</span><span class="o">.</span><span class="n">is_precedent</span><span class="p">(</span><span class="n">operators</span><span class="o">.</span><span class="n">filter_op</span><span class="p">,</span> <span class="n">against</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Grouping</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">memoized_property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">type</span>

    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span><span class="p">)</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_copy_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">_clone</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">criterion</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_from_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span>
            <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
                <span class="o">*</span><span class="p">[</span>
                    <span class="n">c</span><span class="o">.</span><span class="n">_from_objects</span>
                    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">criterion</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="p">]</span>
            <span class="p">)</span>
        <span class="p">)</span>


<span class="k">class</span> <span class="nc">Label</span><span class="p">(</span><span class="n">ColumnElement</span><span class="p">):</span>
    <span class="sd">"""Represents a column label (AS).</span>

<span class="sd">    Represent a label, as typically applied to any column-level</span>
<span class="sd">    element using the ``AS`` sql keyword.</span>

<span class="sd">    """</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s2">"label"</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""Return a :class:`Label` object for the</span>
<span class="sd">        given :class:`.ColumnElement`.</span>

<span class="sd">        A label changes the name of an element in the columns clause of a</span>
<span class="sd">        ``SELECT`` statement, typically via the ``AS`` SQL keyword.</span>

<span class="sd">        This functionality is more conveniently available via the</span>
<span class="sd">        :meth:`.ColumnElement.label` method on :class:`.ColumnElement`.</span>

<span class="sd">        :param name: label name</span>

<span class="sd">        :param obj: a :class:`.ColumnElement`.</span>

<span class="sd">        """</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">Label</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_label</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">_label</span>

        <span class="k">while</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">Label</span><span class="p">):</span>
            <span class="n">element</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">element</span>

        <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">_anonymous_label</span><span class="p">(</span>
                <span class="s2">"</span><span class="si">%%</span><span class="s2">(</span><span class="si">%d</span><span class="s2"> </span><span class="si">%s</span><span class="s2">)s"</span> <span class="o">%</span> <span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s2">"name"</span><span class="p">,</span> <span class="s2">"anon"</span><span class="p">))</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_element</span> <span class="o">=</span> <span class="n">element</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_type</span> <span class="o">=</span> <span class="n">type_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_proxies</span> <span class="o">=</span> <span class="p">[</span><span class="n">element</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_element</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type</span><span class="p">)</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">memoized_property</span>
    <span class="k">def</span> <span class="nf">_is_implicitly_boolean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">_is_implicitly_boolean</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">memoized_property</span>
    <span class="k">def</span> <span class="nf">_allow_label_resolve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">_allow_label_resolve</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_order_by_label_element</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">memoized_property</span>
    <span class="k">def</span> <span class="nf">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">type_api</span><span class="o">.</span><span class="n">to_instance</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_type</span> <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_element</span><span class="p">,</span> <span class="s2">"type"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">memoized_property</span>
    <span class="k">def</span> <span class="nf">element</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_element</span><span class="o">.</span><span class="n">self_group</span><span class="p">(</span><span class="n">against</span><span class="o">=</span><span class="n">operators</span><span class="o">.</span><span class="n">as_</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">self_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">against</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_inner</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_element</span><span class="o">.</span><span class="n">self_group</span><span class="p">,</span> <span class="n">against</span><span class="o">=</span><span class="n">against</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_negate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_to_inner</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_element</span><span class="o">.</span><span class="n">_negate</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_apply_to_inner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="n">sub_element</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sub_element</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_element</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Label</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">sub_element</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_type</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">primary_key</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">primary_key</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">foreign_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">foreign_keys</span>

    <span class="k">def</span> <span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,)</span>

    <span class="k">def</span> <span class="nf">_copy_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clone</span><span class="o">=</span><span class="n">_clone</span><span class="p">,</span> <span class="n">anonymize_labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_element</span> <span class="o">=</span> <span class="n">clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_element</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"element"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">"_allow_label_resolve"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">anonymize_labels</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_label</span> <span class="o">=</span> <span class="n">_anonymous_label</span><span class="p">(</span>
                <span class="s2">"</span><span class="si">%%</span><span class="s2">(</span><span class="si">%d</span><span class="s2"> </span><span class="si">%s</span><span class="s2">)s"</span>
                <span class="o">%</span> <span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="p">,</span> <span class="s2">"name"</span><span class="p">,</span> <span class="s2">"anon"</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_from_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">_from_objects</span>

    <span class="k">def</span> <span class="nf">_make_proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selectable</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">_make_proxy</span><span class="p">(</span>
            <span class="n">selectable</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span> <span class="k">if</span> <span class="n">name</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">disallow_is_literal</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">e</span><span class="o">.</span><span class="n">_proxies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">e</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type</span>
        <span class="k">return</span> <span class="n">e</span>


<span class="k">class</span> <span class="nc">ColumnClause</span><span class="p">(</span><span class="n">Immutable</span><span class="p">,</span> <span class="n">ColumnElement</span><span class="p">):</span>
    <span class="sd">"""Represents a column expression from any textual string.</span>

<span class="sd">    The :class:`.ColumnClause`, a lightweight analogue to the</span>
<span class="sd">    :class:`.Column` class, is typically invoked using the</span>
<span class="sd">    :func:`.column` function, as in::</span>

<span class="sd">        from sqlalchemy import column</span>

<span class="sd">        id, name = column("id"), column("name")</span>
<span class="sd">        stmt = select([id, name]).select_from("user")</span>

<span class="sd">    The above statement would produce SQL like::</span>

<span class="sd">        SELECT id, name FROM user</span>

<span class="sd">    :class:`.ColumnClause` is the immediate superclass of the schema-specific</span>
<span class="sd">    :class:`.Column` object.  While the :class:`.Column` class has all the</span>
<span class="sd">    same capabilities as :class:`.ColumnClause`, the :class:`.ColumnClause`</span>
<span class="sd">    class is usable by itself in those cases where behavioral requirements</span>
<span class="sd">    are limited to simple SQL expression generation.  The object has none of</span>
<span class="sd">    the associations with schema-level metadata or with execution-time</span>
<span class="sd">    behavior that :class:`.Column` does, so in that sense is a "lightweight"</span>
<span class="sd">    version of :class:`.Column`.</span>

<span class="sd">    Full details on :class:`.ColumnClause` usage is at :func:`.column`.</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :func:`.column`</span>

<span class="sd">        :class:`.Column`</span>

<span class="sd">    """</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s2">"column"</span>

    <span class="n">onupdate</span> <span class="o">=</span> <span class="n">default</span> <span class="o">=</span> <span class="n">server_default</span> <span class="o">=</span> <span class="n">server_onupdate</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">_is_multiparam_column</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">_memoized_property</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">group_expirable_memoized_property</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_literal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">_selectable</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">"""Produce a :class:`.ColumnClause` object.</span>

<span class="sd">        The :class:`.ColumnClause` is a lightweight analogue to the</span>
<span class="sd">        :class:`.Column` class.  The :func:`.column` function can</span>
<span class="sd">        be invoked with just a name alone, as in::</span>

<span class="sd">            from sqlalchemy import column</span>

<span class="sd">            id, name = column("id"), column("name")</span>
<span class="sd">            stmt = select([id, name]).select_from("user")</span>

<span class="sd">        The above statement would produce SQL like::</span>

<span class="sd">            SELECT id, name FROM user</span>

<span class="sd">        Once constructed, :func:`.column` may be used like any other SQL</span>
<span class="sd">        expression element such as within :func:`.select` constructs::</span>

<span class="sd">            from sqlalchemy.sql import column</span>

<span class="sd">            id, name = column("id"), column("name")</span>
<span class="sd">            stmt = select([id, name]).select_from("user")</span>

<span class="sd">        The text handled by :func:`.column` is assumed to be handled</span>
<span class="sd">        like the name of a database column; if the string contains mixed case,</span>
<span class="sd">        special characters, or matches a known reserved word on the target</span>
<span class="sd">        backend, the column expression will render using the quoting</span>
<span class="sd">        behavior determined by the backend.  To produce a textual SQL</span>
<span class="sd">        expression that is rendered exactly without any quoting,</span>
<span class="sd">        use :func:`.literal_column` instead, or pass ``True`` as the</span>
<span class="sd">        value of :paramref:`.column.is_literal`.   Additionally, full SQL</span>
<span class="sd">        statements are best handled using the :func:`.text` construct.</span>

<span class="sd">        :func:`.column` can be used in a table-like</span>
<span class="sd">        fashion by combining it with the :func:`.table` function</span>
<span class="sd">        (which is the lightweight analogue to :class:`.Table`) to produce</span>
<span class="sd">        a working table construct with minimal boilerplate::</span>

<span class="sd">            from sqlalchemy import table, column, select</span>

<span class="sd">            user = table("user",</span>
<span class="sd">                    column("id"),</span>
<span class="sd">                    column("name"),</span>
<span class="sd">                    column("description"),</span>
<span class="sd">            )</span>

<span class="sd">            stmt = select([user.c.description]).where(user.c.name == 'wendy')</span>

<span class="sd">        A :func:`.column` / :func:`.table` construct like that illustrated</span>
<span class="sd">        above can be created in an</span>
<span class="sd">        ad-hoc fashion and is not associated with any</span>
<span class="sd">        :class:`.schema.MetaData`, DDL, or events, unlike its</span>
<span class="sd">        :class:`.Table` counterpart.</span>

<span class="sd">        .. versionchanged:: 1.0.0 :func:`.expression.column` can now</span>
<span class="sd">           be imported from the plain ``sqlalchemy`` namespace like any</span>
<span class="sd">           other SQL element.</span>

<span class="sd">        :param text: the text of the element.</span>

<span class="sd">        :param type: :class:`.types.TypeEngine` object which can associate</span>
<span class="sd">          this :class:`.ColumnClause` with a type.</span>

<span class="sd">        :param is_literal: if True, the :class:`.ColumnClause` is assumed to</span>
<span class="sd">          be an exact expression that will be delivered to the output with no</span>
<span class="sd">          quoting rules applied regardless of case sensitive settings. the</span>
<span class="sd">          :func:`.literal_column()` function essentially invokes</span>
<span class="sd">          :func:`.column` while passing ``is_literal=True``.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :class:`.Column`</span>

<span class="sd">            :func:`.literal_column`</span>

<span class="sd">            :func:`.table`</span>

<span class="sd">            :func:`.text`</span>

<span class="sd">            :ref:`sqlexpression_literal_column`</span>

<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">text</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">table</span> <span class="o">=</span> <span class="n">_selectable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type_api</span><span class="o">.</span><span class="n">to_instance</span><span class="p">(</span><span class="n">type_</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_literal</span> <span class="o">=</span> <span class="n">is_literal</span>

    <span class="k">def</span> <span class="nf">_compare_name_for_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_literal</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">_textual</span>
            <span class="ow">or</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">"proxy_set"</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ColumnClause</span><span class="p">)</span>
                <span class="ow">and</span> <span class="p">(</span>
                    <span class="n">other</span><span class="o">.</span><span class="n">is_literal</span>
                    <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">table</span> <span class="ow">is</span> <span class="kc">None</span>
                    <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">_textual</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">"name"</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">"_label"</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_label</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">proxy_set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proxy_set</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">"table"</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_set_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_memoized_property</span><span class="o">.</span><span class="n">expire_instance</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">"table"</span><span class="p">]</span> <span class="o">=</span> <span class="n">table</span>

    <span class="n">table</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_table</span><span class="p">,</span> <span class="n">_set_table</span><span class="p">)</span>

    <span class="nd">@_memoized_property</span>
    <span class="k">def</span> <span class="nf">_from_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span>
        <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">t</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">memoized_property</span>
    <span class="k">def</span> <span class="nf">description</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">util</span><span class="o">.</span><span class="n">py3k</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">"ascii"</span><span class="p">,</span> <span class="s2">"backslashreplace"</span><span class="p">)</span>

    <span class="nd">@_memoized_property</span>
    <span class="k">def</span> <span class="nf">_key_label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_label</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span>

    <span class="nd">@_memoized_property</span>
    <span class="k">def</span> <span class="nf">_label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_label</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="nd">@_memoized_property</span>
    <span class="k">def</span> <span class="nf">_render_label_in_columns_clause</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_ddl_label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_label</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dedupe_on_key</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_gen_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">dedupe_on_key</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_literal</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">elif</span> <span class="n">t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">t</span><span class="o">.</span><span class="n">named_with_column</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">"schema"</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">label</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">"."</span><span class="p">,</span> <span class="s2">"_"</span><span class="p">)</span> <span class="o">+</span> <span class="s2">"_"</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">"_"</span> <span class="o">+</span> <span class="n">name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">label</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">"_"</span> <span class="o">+</span> <span class="n">name</span>

            <span class="c1"># propagate name quoting rules for labels.</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">"quote"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">quoted_name</span><span class="p">):</span>
                    <span class="n">label</span><span class="o">.</span><span class="n">quote</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">quote</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="n">quoted_name</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">name</span><span class="o">.</span><span class="n">quote</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s2">"quote"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># can't get this situation to occur, so let's</span>
                <span class="c1"># assert false on it for now</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">quoted_name</span><span class="p">)</span>
                <span class="n">label</span> <span class="o">=</span> <span class="n">quoted_name</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">quote</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">dedupe_on_key</span><span class="p">:</span>
                <span class="c1"># ensure the label name doesn't conflict with that of an</span>
                <span class="c1"># existing column.   note that this implies that any Column</span>
                <span class="c1"># must **not** set up its _label before its parent table has</span>
                <span class="c1"># all of its other Column objects set up.  There are several</span>
                <span class="c1"># tables in the test suite which will fail otherwise; example:</span>
                <span class="c1"># table "owner" has columns "name" and "owner_name".  Therefore</span>
                <span class="c1"># column owner.name cannot use the label "owner_name", it has</span>
                <span class="c1"># to be "owner_name_1".</span>
                <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">c</span><span class="p">:</span>
                    <span class="n">_label</span> <span class="o">=</span> <span class="n">label</span>
                    <span class="n">counter</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">while</span> <span class="n">_label</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">c</span><span class="p">:</span>
                        <span class="n">_label</span> <span class="o">=</span> <span class="n">label</span> <span class="o">+</span> <span class="s2">"_"</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">counter</span><span class="p">)</span>
                        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="n">_label</span>

            <span class="k">return</span> <span class="n">_as_truncated</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">_bind_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BindParameter</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">,</span>
            <span class="n">obj</span><span class="p">,</span>
            <span class="n">_compared_to_operator</span><span class="o">=</span><span class="n">operator</span><span class="p">,</span>
            <span class="n">_compared_to_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
            <span class="n">type_</span><span class="o">=</span><span class="n">type_</span><span class="p">,</span>
            <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_make_proxy</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">selectable</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">attach</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">name_is_truncatable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">disallow_is_literal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kw</span>
    <span class="p">):</span>
        <span class="c1"># the "is_literal" flag normally should never be propagated; a proxied</span>
        <span class="c1"># column is always a SQL identifier and never the actual expression</span>
        <span class="c1"># being evaluated. however, there is a case where the "is_literal" flag</span>
        <span class="c1"># might be used to allow the given identifier to have a fixed quoting</span>
        <span class="c1"># pattern already, so maintain the flag for the proxy unless a</span>
        <span class="c1"># :class:`.Label` object is creating the proxy.  See [ticket:4730].</span>
        <span class="n">is_literal</span> <span class="o">=</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="n">disallow_is_literal</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_literal</span>
            <span class="ow">and</span> <span class="p">(</span>
                <span class="c1"># note this does not accommodate for quoted_name differences</span>
                <span class="c1"># right now</span>
                <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="ow">or</span> <span class="n">name</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
            <span class="n">_as_truncated</span><span class="p">(</span><span class="n">name</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">name_is_truncatable</span>
            <span class="k">else</span> <span class="p">(</span><span class="n">name</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
            <span class="n">type_</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
            <span class="n">_selectable</span><span class="o">=</span><span class="n">selectable</span><span class="p">,</span>
            <span class="n">is_literal</span><span class="o">=</span><span class="n">is_literal</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">c</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span>
        <span class="n">c</span><span class="o">.</span><span class="n">_proxies</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">selectable</span><span class="o">.</span><span class="n">_is_clone_of</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">c</span><span class="o">.</span><span class="n">_is_clone_of</span> <span class="o">=</span> <span class="n">selectable</span><span class="o">.</span><span class="n">_is_clone_of</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">attach</span><span class="p">:</span>
            <span class="n">selectable</span><span class="o">.</span><span class="n">_columns</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
        <span class="k">return</span> <span class="n">c</span>


<span class="k">class</span> <span class="nc">CollationClause</span><span class="p">(</span><span class="n">ColumnElement</span><span class="p">):</span>
    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s2">"collation"</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">collation</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collation</span> <span class="o">=</span> <span class="n">collation</span>


<span class="k">class</span> <span class="nc">_IdentifiedClause</span><span class="p">(</span><span class="n">Executable</span><span class="p">,</span> <span class="n">ClauseElement</span><span class="p">):</span>

    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s2">"identified"</span>
    <span class="n">_execution_options</span> <span class="o">=</span> <span class="n">Executable</span><span class="o">.</span><span class="n">_execution_options</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
        <span class="p">{</span><span class="s2">"autocommit"</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ident</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ident</span> <span class="o">=</span> <span class="n">ident</span>


<span class="k">class</span> <span class="nc">SavepointClause</span><span class="p">(</span><span class="n">_IdentifiedClause</span><span class="p">):</span>
    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s2">"savepoint"</span>


<span class="k">class</span> <span class="nc">RollbackToSavepointClause</span><span class="p">(</span><span class="n">_IdentifiedClause</span><span class="p">):</span>
    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s2">"rollback_to_savepoint"</span>


<span class="k">class</span> <span class="nc">ReleaseSavepointClause</span><span class="p">(</span><span class="n">_IdentifiedClause</span><span class="p">):</span>
    <span class="n">__visit_name__</span> <span class="o">=</span> <span class="s2">"release_savepoint"</span>


<span class="k">class</span> <span class="nc">quoted_name</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">MemoizedSlots</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">text_type</span><span class="p">):</span>
    <span class="sd">"""Represent a SQL identifier combined with quoting preferences.</span>

<span class="sd">    :class:`.quoted_name` is a Python unicode/str subclass which</span>
<span class="sd">    represents a particular identifier name along with a</span>
<span class="sd">    ``quote`` flag.  This ``quote`` flag, when set to</span>
<span class="sd">    ``True`` or ``False``, overrides automatic quoting behavior</span>
<span class="sd">    for this identifier in order to either unconditionally quote</span>
<span class="sd">    or to not quote the name.  If left at its default of ``None``,</span>
<span class="sd">    quoting behavior is applied to the identifier on a per-backend basis</span>
<span class="sd">    based on an examination of the token itself.</span>

<span class="sd">    A :class:`.quoted_name` object with ``quote=True`` is also</span>
<span class="sd">    prevented from being modified in the case of a so-called</span>
<span class="sd">    "name normalize" option.  Certain database backends, such as</span>
<span class="sd">    Oracle, Firebird, and DB2 "normalize" case-insensitive names</span>
<span class="sd">    as uppercase.  The SQLAlchemy dialects for these backends</span>
<span class="sd">    convert from SQLAlchemy's lower-case-means-insensitive convention</span>
<span class="sd">    to the upper-case-means-insensitive conventions of those backends.</span>
<span class="sd">    The ``quote=True`` flag here will prevent this conversion from occurring</span>
<span class="sd">    to support an identifier that's quoted as all lower case against</span>
<span class="sd">    such a backend.</span>

<span class="sd">    The :class:`.quoted_name` object is normally created automatically</span>
<span class="sd">    when specifying the name for key schema constructs such as</span>
<span class="sd">    :class:`.Table`, :class:`.Column`, and others.  The class can also be</span>
<span class="sd">    passed explicitly as the name to any function that receives a name which</span>
<span class="sd">    can be quoted.  Such as to use the :meth:`.Engine.has_table` method with</span>
<span class="sd">    an unconditionally quoted name::</span>

<span class="sd">        from sqlalchemy import create_engine</span>
<span class="sd">        from sqlalchemy.sql import quoted_name</span>

<span class="sd">        engine = create_engine("oracle+cx_oracle://some_dsn")</span>
<span class="sd">        engine.has_table(quoted_name("some_table", True))</span>

<span class="sd">    The above logic will run the "has table" logic against the Oracle backend,</span>
<span class="sd">    passing the name exactly as ``"some_table"`` without converting to</span>
<span class="sd">    upper case.</span>

<span class="sd">    .. versionadded:: 0.9.0</span>

<span class="sd">    .. versionchanged:: 1.2 The :class:`.quoted_name` construct is now</span>
<span class="sd">       importable from ``sqlalchemy.sql``, in addition to the previous</span>
<span class="sd">       location of ``sqlalchemy.sql.elements``.</span>

<span class="sd">    """</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="s2">"quote"</span><span class="p">,</span> <span class="s2">"lower"</span><span class="p">,</span> <span class="s2">"upper"</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">quote</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># experimental - don't bother with quoted_name</span>
        <span class="c1"># if quote flag is None.  doesn't seem to make any dent</span>
        <span class="c1"># in performance however</span>
        <span class="c1"># elif not sprcls and quote is None:</span>
        <span class="c1">#   return value</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">quote</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">value</span><span class="o">.</span><span class="n">quote</span> <span class="o">==</span> <span class="n">quote</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">quoted_name</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">quote</span> <span class="o">=</span> <span class="n">quote</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">quoted_name</span><span class="p">,</span> <span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">quote</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_memoized_method_lower</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">quote</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_memoized_method_upper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">quote</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">util</span><span class="o">.</span><span class="n">py2k</span><span class="p">:</span>
            <span class="n">backslashed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">"ascii"</span><span class="p">,</span> <span class="s2">"backslashreplace"</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">util</span><span class="o">.</span><span class="n">py2k</span><span class="p">:</span>
                <span class="n">backslashed</span> <span class="o">=</span> <span class="n">backslashed</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">"ascii"</span><span class="p">)</span>
            <span class="k">return</span> <span class="s2">"'</span><span class="si">%s</span><span class="s2">'"</span> <span class="o">%</span> <span class="n">backslashed</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_truncated_label</span><span class="p">(</span><span class="n">quoted_name</span><span class="p">):</span>
    <span class="sd">"""A unicode subclass used to identify symbolic "</span>
<span class="sd">    "names that may require truncation."""</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">quote</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">quote</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">"quote"</span><span class="p">,</span> <span class="n">quote</span><span class="p">)</span>
        <span class="c1"># return super(_truncated_label, cls).__new__(cls, value, quote, True)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">_truncated_label</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">quote</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">quote</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">map_</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>


<span class="k">class</span> <span class="nc">conv</span><span class="p">(</span><span class="n">_truncated_label</span><span class="p">):</span>
    <span class="sd">"""Mark a string indicating that a name has already been converted</span>
<span class="sd">    by a naming convention.</span>

<span class="sd">    This is a string subclass that indicates a name that should not be</span>
<span class="sd">    subject to any further naming conventions.</span>

<span class="sd">    E.g. when we create a :class:`.Constraint` using a naming convention</span>
<span class="sd">    as follows::</span>

<span class="sd">        m = MetaData(naming_convention={</span>
<span class="sd">            "ck": "ck_%(table_name)s_%(constraint_name)s"</span>
<span class="sd">        })</span>
<span class="sd">        t = Table('t', m, Column('x', Integer),</span>
<span class="sd">                        CheckConstraint('x &gt; 5', name='x5'))</span>

<span class="sd">    The name of the above constraint will be rendered as ``"ck_t_x5"``.</span>
<span class="sd">    That is, the existing name ``x5`` is used in the naming convention as the</span>
<span class="sd">    ``constraint_name`` token.</span>

<span class="sd">    In some situations, such as in migration scripts, we may be rendering</span>
<span class="sd">    the above :class:`.CheckConstraint` with a name that's already been</span>
<span class="sd">    converted.  In order to make sure the name isn't double-modified, the</span>
<span class="sd">    new name is applied using the :func:`.schema.conv` marker.  We can</span>
<span class="sd">    use this explicitly as follows::</span>


<span class="sd">        m = MetaData(naming_convention={</span>
<span class="sd">            "ck": "ck_%(table_name)s_%(constraint_name)s"</span>
<span class="sd">        })</span>
<span class="sd">        t = Table('t', m, Column('x', Integer),</span>
<span class="sd">                        CheckConstraint('x &gt; 5', name=conv('ck_t_x5')))</span>

<span class="sd">    Where above, the :func:`.schema.conv` marker indicates that the constraint</span>
<span class="sd">    name here is final, and the name will render as ``"ck_t_x5"`` and not</span>
<span class="sd">    ``"ck_t_ck_t_x5"``</span>

<span class="sd">    .. versionadded:: 0.9.4</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :ref:`constraint_naming_conventions`</span>

<span class="sd">    """</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>


<span class="k">class</span> <span class="nc">_defer_name</span><span class="p">(</span><span class="n">_truncated_label</span><span class="p">):</span>
    <span class="sd">"""mark a name as 'deferred' for the purposes of automated name</span>
<span class="sd">    generation.</span>

<span class="sd">    """</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_NONE_NAME</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">conv</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">_defer_name</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="p">),)</span>


<span class="k">class</span> <span class="nc">_defer_none_name</span><span class="p">(</span><span class="n">_defer_name</span><span class="p">):</span>
    <span class="sd">"""indicate a 'deferred' name that was ultimately the value None."""</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>


<span class="n">_NONE_NAME</span> <span class="o">=</span> <span class="n">_defer_none_name</span><span class="p">(</span><span class="s2">"_unnamed_"</span><span class="p">)</span>

<span class="c1"># for backwards compatibility in case</span>
<span class="c1"># someone is re-implementing the</span>
<span class="c1"># _truncated_identifier() sequence in a custom</span>
<span class="c1"># compiler</span>
<span class="n">_generated_label</span> <span class="o">=</span> <span class="n">_truncated_label</span>


<span class="k">class</span> <span class="nc">_anonymous_label</span><span class="p">(</span><span class="n">_truncated_label</span><span class="p">):</span>
    <span class="sd">"""A unicode subclass used to identify anonymously</span>
<span class="sd">    generated names."""</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_anonymous_label</span><span class="p">(</span>
            <span class="n">quoted_name</span><span class="p">(</span>
                <span class="n">util</span><span class="o">.</span><span class="n">text_type</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="n">other</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">quote</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_anonymous_label</span><span class="p">(</span>
            <span class="n">quoted_name</span><span class="p">(</span>
                <span class="n">util</span><span class="o">.</span><span class="n">text_type</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">quote</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">map_</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">quote</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># preserve quoting only if necessary</span>
            <span class="k">return</span> <span class="n">quoted_name</span><span class="p">(</span><span class="bp">self</span> <span class="o">%</span> <span class="n">map_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">quote</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># else skip the constructor call</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="o">%</span> <span class="n">map_</span>


<span class="k">def</span> <span class="nf">_as_truncated</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="sd">"""coerce the given value to :class:`._truncated_label`.</span>

<span class="sd">    Existing :class:`._truncated_label` and</span>
<span class="sd">    :class:`._anonymous_label` objects are passed</span>
<span class="sd">    unchanged.</span>
<span class="sd">    """</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">_truncated_label</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">value</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_truncated_label</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_string_or_unprintable</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">element</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">"unprintable element </span><span class="si">%r</span><span class="s2">"</span> <span class="o">%</span> <span class="n">element</span>


<span class="k">def</span> <span class="nf">_expand_cloned</span><span class="p">(</span><span class="n">elements</span><span class="p">):</span>
    <span class="sd">"""expand the given set of ClauseElements to be the set of all 'cloned'</span>
<span class="sd">    predecessors.</span>

<span class="sd">    """</span>
    <span class="k">return</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">_cloned_set</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">_select_iterables</span><span class="p">(</span><span class="n">elements</span><span class="p">):</span>
    <span class="sd">"""expand tables into individual columns in the</span>
<span class="sd">    given list of column expressions.</span>

<span class="sd">    """</span>
    <span class="k">return</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">_select_iterable</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">_cloned_intersection</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">"""return the intersection of sets a and b, counting</span>
<span class="sd">    any overlap between 'cloned' predecessors.</span>

<span class="sd">    The returned set is in terms of the entities present within 'a'.</span>

<span class="sd">    """</span>
    <span class="n">all_overlap</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">_expand_cloned</span><span class="p">(</span><span class="n">a</span><span class="p">))</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">_expand_cloned</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span>
        <span class="n">elem</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">a</span> <span class="k">if</span> <span class="n">all_overlap</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">elem</span><span class="o">.</span><span class="n">_cloned_set</span><span class="p">)</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">_cloned_difference</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">all_overlap</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">_expand_cloned</span><span class="p">(</span><span class="n">a</span><span class="p">))</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">_expand_cloned</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span>
        <span class="n">elem</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">a</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">all_overlap</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">elem</span><span class="o">.</span><span class="n">_cloned_set</span><span class="p">)</span>
    <span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">dependencies</span><span class="p">(</span><span class="s2">"sqlalchemy.sql.functions"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_labeled</span><span class="p">(</span><span class="n">functions</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s2">"name"</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span>
        <span class="n">element</span><span class="p">,</span> <span class="n">functions</span><span class="o">.</span><span class="n">FunctionElement</span>
    <span class="p">):</span>
        <span class="k">return</span> <span class="n">element</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">element</span>


<span class="k">def</span> <span class="nf">_is_column</span><span class="p">(</span><span class="n">col</span><span class="p">):</span>
    <span class="sd">"""True if ``col`` is an instance of :class:`.ColumnElement`."""</span>

    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">ColumnElement</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_find_columns</span><span class="p">(</span><span class="n">clause</span><span class="p">):</span>
    <span class="sd">"""locate Column objects within the given expression."""</span>

    <span class="n">cols</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">column_set</span><span class="p">()</span>
    <span class="n">traverse</span><span class="p">(</span><span class="n">clause</span><span class="p">,</span> <span class="p">{},</span> <span class="p">{</span><span class="s2">"column"</span><span class="p">:</span> <span class="n">cols</span><span class="o">.</span><span class="n">add</span><span class="p">})</span>
    <span class="k">return</span> <span class="n">cols</span>


<span class="c1"># there is some inconsistency here between the usage of</span>
<span class="c1"># inspect() vs. checking for Visitable and __clause_element__.</span>
<span class="c1"># Ideally all functions here would derive from inspect(),</span>
<span class="c1"># however the inspect() versions add significant callcount</span>
<span class="c1"># overhead for critical functions like _interpret_as_column_or_from().</span>
<span class="c1"># Generally, the column-based functions are more performance critical</span>
<span class="c1"># and are fine just checking for __clause_element__().  It is only</span>
<span class="c1"># _interpret_as_from() where we'd like to be able to receive ORM entities</span>
<span class="c1"># that have no defined namespace, hence inspect() is needed there.</span>


<span class="k">def</span> <span class="nf">_column_as_key</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">element</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s2">"__clause_element__"</span><span class="p">):</span>
        <span class="n">element</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">__clause_element__</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">element</span><span class="o">.</span><span class="n">key</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">_clause_element_as_expr</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s2">"__clause_element__"</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">element</span><span class="o">.</span><span class="n">__clause_element__</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">element</span>


<span class="k">def</span> <span class="nf">_literal_as_label_reference</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_textual_label_reference</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s2">"__clause_element__"</span><span class="p">):</span>
        <span class="n">element</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">__clause_element__</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">_literal_as_text</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_literal_and_labels_as_label_reference</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_textual_label_reference</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s2">"__clause_element__"</span><span class="p">):</span>
        <span class="n">element</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">__clause_element__</span><span class="p">()</span>

    <span class="k">if</span> <span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">ColumnElement</span><span class="p">)</span>
        <span class="ow">and</span> <span class="n">element</span><span class="o">.</span><span class="n">_order_by_label_element</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="p">):</span>
        <span class="k">return</span> <span class="n">_label_reference</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_literal_as_text</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_expression_literal_as_text</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_literal_as_text</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_literal_as</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">text_fallback</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">Visitable</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">element</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s2">"__clause_element__"</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">element</span><span class="o">.</span><span class="n">__clause_element__</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">text_fallback</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">NoneType</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">_const_expr</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
            <span class="s2">"SQL expression object expected, got object of type </span><span class="si">%r</span><span class="s2"> "</span>
            <span class="s2">"instead"</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
        <span class="p">)</span>


<span class="k">def</span> <span class="nf">_literal_as_text</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">allow_coercion_to_text</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">allow_coercion_to_text</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_literal_as</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">TextClause</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_literal_as</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">_no_text_coercion</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_literal_as_column</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_literal_as</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">ColumnClause</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_no_column_coercion</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
    <span class="n">element</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
    <span class="n">guess_is_literal</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">_guess_straight_column</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
    <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
        <span class="s2">"Textual column expression </span><span class="si">%(column)r</span><span class="s2"> should be "</span>
        <span class="s2">"explicitly declared with text(</span><span class="si">%(column)r</span><span class="s2">), "</span>
        <span class="s2">"or use </span><span class="si">%(literal_column)s</span><span class="s2">(</span><span class="si">%(column)r</span><span class="s2">) "</span>
        <span class="s2">"for more specificity"</span>
        <span class="o">%</span> <span class="p">{</span>
            <span class="s2">"column"</span><span class="p">:</span> <span class="n">util</span><span class="o">.</span><span class="n">ellipses_string</span><span class="p">(</span><span class="n">element</span><span class="p">),</span>
            <span class="s2">"literal_column"</span><span class="p">:</span> <span class="s2">"literal_column"</span>
            <span class="k">if</span> <span class="n">guess_is_literal</span>
            <span class="k">else</span> <span class="s2">"column"</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">_no_text_coercion</span><span class="p">(</span>
    <span class="n">element</span><span class="p">,</span> <span class="n">exc_cls</span><span class="o">=</span><span class="n">exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">err</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
    <span class="n">util</span><span class="o">.</span><span class="n">raise_</span><span class="p">(</span>
        <span class="n">exc_cls</span><span class="p">(</span>
            <span class="s2">"</span><span class="si">%(extra)s</span><span class="s2">Textual SQL expression </span><span class="si">%(expr)r</span><span class="s2"> should be "</span>
            <span class="s2">"explicitly declared as text(</span><span class="si">%(expr)r</span><span class="s2">)"</span>
            <span class="o">%</span> <span class="p">{</span>
                <span class="s2">"expr"</span><span class="p">:</span> <span class="n">util</span><span class="o">.</span><span class="n">ellipses_string</span><span class="p">(</span><span class="n">element</span><span class="p">),</span>
                <span class="s2">"extra"</span><span class="p">:</span> <span class="s2">"</span><span class="si">%s</span><span class="s2"> "</span> <span class="o">%</span> <span class="n">extra</span> <span class="k">if</span> <span class="n">extra</span> <span class="k">else</span> <span class="s2">""</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">),</span>
        <span class="n">replace_context</span><span class="o">=</span><span class="n">err</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">_no_literals</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s2">"__clause_element__"</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">element</span><span class="o">.</span><span class="n">__clause_element__</span><span class="p">()</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">Visitable</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
            <span class="s2">"Ambiguous literal: </span><span class="si">%r</span><span class="s2">.  Use the 'text()' "</span>
            <span class="s2">"function to indicate a SQL expression "</span>
            <span class="s2">"literal, or 'literal()' to indicate a "</span>
            <span class="s2">"bound value."</span> <span class="o">%</span> <span class="p">(</span><span class="n">element</span><span class="p">,)</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">element</span>


<span class="k">def</span> <span class="nf">_is_literal</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">Visitable</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span>
        <span class="n">element</span><span class="p">,</span> <span class="s2">"__clause_element__"</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">_only_column_elements_or_none</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">element</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_only_column_elements</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_only_column_elements</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s2">"__clause_element__"</span><span class="p">):</span>
        <span class="n">element</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">__clause_element__</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">ColumnElement</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
            <span class="s2">"Column-based expression object expected for argument "</span>
            <span class="s2">"'</span><span class="si">%s</span><span class="s2">'; got: '</span><span class="si">%s</span><span class="s2">', type </span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">element</span><span class="p">))</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">element</span>


<span class="k">def</span> <span class="nf">_literal_as_binds</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s2">"__clause_element__"</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">element</span><span class="o">.</span><span class="n">__clause_element__</span><span class="p">()</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">Visitable</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">element</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Null</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BindParameter</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="n">type_</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">element</span>


<span class="n">_guess_straight_column</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">"^\w\S*$"</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">I</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_interpret_as_column_or_from</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">Visitable</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">element</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s2">"__clause_element__"</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">element</span><span class="o">.</span><span class="n">__clause_element__</span><span class="p">()</span>

    <span class="n">insp</span> <span class="o">=</span> <span class="n">inspection</span><span class="o">.</span><span class="n">inspect</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">raiseerr</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">insp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">NoneType</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">_const_expr</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">insp</span><span class="p">,</span> <span class="s2">"selectable"</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">insp</span><span class="o">.</span><span class="n">selectable</span>

    <span class="c1"># be forgiving as this is an extremely common</span>
    <span class="c1"># and known expression</span>
    <span class="k">if</span> <span class="n">element</span> <span class="o">==</span> <span class="s2">"*"</span><span class="p">:</span>
        <span class="n">guess_is_literal</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="p">(</span><span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">ColumnClause</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">element</span><span class="p">),</span> <span class="n">is_literal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_no_column_coercion</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ColumnClause</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">is_literal</span><span class="o">=</span><span class="n">guess_is_literal</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_const_expr</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="p">(</span><span class="n">Null</span><span class="p">,</span> <span class="n">False_</span><span class="p">,</span> <span class="n">True_</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">element</span>
    <span class="k">elif</span> <span class="n">element</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Null</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">element</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">False_</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">element</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">True_</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span><span class="s2">"Expected None, False, or True"</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_type_from_args</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">_isnull</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">type</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">type_api</span><span class="o">.</span><span class="n">NULLTYPE</span>


<span class="k">def</span> <span class="nf">_corresponding_column_or_error</span><span class="p">(</span><span class="n">fromclause</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">require_embedded</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">fromclause</span><span class="o">.</span><span class="n">corresponding_column</span><span class="p">(</span>
        <span class="n">column</span><span class="p">,</span> <span class="n">require_embedded</span><span class="o">=</span><span class="n">require_embedded</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
            <span class="s2">"Given column '</span><span class="si">%s</span><span class="s2">', attached to table '</span><span class="si">%s</span><span class="s2">', "</span>
            <span class="s2">"failed to locate a corresponding column from table '</span><span class="si">%s</span><span class="s2">'"</span>
            <span class="o">%</span> <span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="s2">"table"</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">fromclause</span><span class="o">.</span><span class="n">description</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">c</span>


<span class="k">class</span> <span class="nc">AnnotatedColumnElement</span><span class="p">(</span><span class="n">Annotated</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="n">Annotated</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="n">ColumnElement</span><span class="o">.</span><span class="n">comparator</span><span class="o">.</span><span class="n">_reset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">"name"</span><span class="p">,</span> <span class="s2">"key"</span><span class="p">,</span> <span class="s2">"table"</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_with_annotations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="n">clone</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">AnnotatedColumnElement</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_with_annotations</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">ColumnElement</span><span class="o">.</span><span class="n">comparator</span><span class="o">.</span><span class="n">_reset</span><span class="p">(</span><span class="n">clone</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">clone</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">memoized_property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""pull 'name' from parent, if not present"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Annotated__element</span><span class="o">.</span><span class="n">name</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">memoized_property</span>
    <span class="k">def</span> <span class="nf">table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""pull 'table' from parent, if not present"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Annotated__element</span><span class="o">.</span><span class="n">table</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">memoized_property</span>
    <span class="k">def</span> <span class="nf">key</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">"""pull 'key' from parent, if not present"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Annotated__element</span><span class="o">.</span><span class="n">key</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">memoized_property</span>
    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Annotated__element</span><span class="o">.</span><span class="n">info</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">memoized_property</span>
    <span class="k">def</span> <span class="nf">anon_label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Annotated__element</span><span class="o">.</span><span class="n">anon_label</span>
</pre></div>

          </article>
        </div>
      </div>
    </main>
  </div>

  <footer class="md-footer">
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
          
          
        </a>
        
      </nav>
    </div>
    <div class="md-footer-meta md-typeset">
      <div class="md-footer-meta__inner md-grid">
        <div class="md-footer-copyright">
          <div class="md-footer-copyright__highlight">
              &#169; Copyright 2020, Don Smiley.
              
          </div>
            Last updated on
              Oct 12, 2020.
            <br/>
            Created using
            <a href="http://www.sphinx-doc.org/">Sphinx</a> 2.4.4.
             and
            <a href="https://github.com/bashtage/sphinx-material/">Material for
              Sphinx</a>
        </div>
      </div>
    </div>
  </footer>
  <script src="../../../_static/javascripts/application.js"></script>
  <script>app.initialize({version: "1.0.4", url: {base: ".."}})</script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle").show();
        $(".toggle").click(function() {
            $(this).children().not(".toggle").toggle(400);
            $(this).toggleClass("open");
        })
    });
</script>

  </body>
</html>